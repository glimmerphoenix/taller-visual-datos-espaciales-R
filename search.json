[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Visualización de datos espaciales con R",
    "section": "",
    "text": "Prefacio\nEn este taller exploramos los fundamentos prácticos para la creación de gráficos para visualización de datos espaciales utilizando el lenguaje R. La representación gráfica de la información de información espacial tiene una gran importancia en distintas áreas de aplicación. Aquí nos centraremos en visualizaciones que puedan resultar especialmente útiles para los/as participantes en Ciencias Agrarias y Ambientales para los/as participantes.\nEste es un taller práctico que presenta ejemplos reales y comandos para crear paso a paso visualizaciones de datos efectivas con R. Además, junto a la explicación de los conceptos clave para entender este proceso también se ofrecen recomendaciones sobre buenas prácticas para crear gáficos más informativos y claros, evitando errores comunes y potenciando su capacidad de condensar gran cantidad de información sin que conlleve una excesiva complejidad para su correcta interpretación.\nLos apuntes para este taller práctico se han realizado con Quarto, una herramienta para creación de documentación científica y programación literaria compatible con R y otros lenguajes de programación científica.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "index.html#requisitos-previos",
    "href": "index.html#requisitos-previos",
    "title": "Visualización de datos espaciales con R",
    "section": "Requisitos previos",
    "text": "Requisitos previos\nPara poder realizar los ejemplos inlcuidos en este taller necesitas tener instalado R y una IDE de desarrollo para este lenguaje. Se recomienda instalar RStudio o MS Visual Code como entorno de programación.\n\nInstalación de R.\nInstalación de RStudio.\n\nAdicionalmente, es necesario instalar una serie de paquetes R antes de ejecutar los ejemplos, para que todas las dependencias estén disponibles en nuestro sistema. Consulta el Apéndice B.1 Paquetes R para comprobar el listado de paquetes R necesarios.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "01-introduccion.html",
    "href": "01-introduccion.html",
    "title": "1  Introducción",
    "section": "",
    "text": "1.1 Tipos de datos espaciales\nLos datos espaciales son aquellos que incluyen cualquier tipo de información que determine una ubicación asociada a una muestra. Un buen ejemplo son las coordenadas de latitud y longitud, que se pueden registrar gracias a la proliferación de dispositivos equipados con GPS. Otros ejemplos serían datos recogidos por provincias en un país o muestras recogidas en una explotación agrícola, dividida previamente en cuadrículas a intervalos regulares para tomar datos en cada sección.\nSegún la clasificación ofrecida por Cressie (1993), podemos distinguir tres tipos principales de datos espaciales:\nAdemás de los datos con dependencias espaciales, en la actualidad surgen también muchos estudios que involucran datos espacio-temporales. En este tipo de datos, las variables observadas tienen simultáneamente tanto dependencia espacial como temporal. Un ejemplo sería la concentración de agentes contaminantes en diferentes zonas de una ciudad, medida diariamente a lo largo de un año.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "01-introduccion.html#tipos-de-datos-espaciales",
    "href": "01-introduccion.html#tipos-de-datos-espaciales",
    "title": "1  Introducción",
    "section": "",
    "text": "Datos geoestadísticos (geostatistical data): datos espaciales cuya variación se produce sobre un espacio continuo. La variable de interés (respuesta) puede ser discreta o continua. Algunos ejemplos son:\n\nNiveles de polución en diferentes zonas de una ciudad.\nNiveles de ozono medidos en una determinada zona geográfica.\nPrecipitación registrada en un territorio durante una jornada.\n\nMalla de datos (lattice data): en este caso, la variación se produce sobre un dominio discreto, por lo que los datos solo pueden ocurrir en un conjunto fijo de localizaciones que se pueden enumerar. En la mayoría de casos, se trata de datos agregados sobre áreas o regiones. Ejemplos:\n\nRegiones censales.\nCódigos postales.\nBarrios o distritos.\nCondados, provincias.\n\nPatrones puntuales (point pattern data): La variable de interés es la localización de eventos que se producen en ubicaciones específicas, sobre un espacio discreto o continuo. Un ejemplo sería la posición de los incendios forestales producidos durante un año en una provincia española. El objetivo más común es determinar si las realizaciones del evento de interés siguen algún patrón dentro del área de estudio o son aleatorias. Más concretamente:\n\nSi las ubicaciones de los eventos son completamente aleatorias (las posiciones de los eventos no afectan a las de otros eventos).\nSi las ubicaciones son uniformes o regulares (cada evento está lo más alejado posible de los eventos vecinos).\nSi las ubicaciones están agregadas o forman clusters (los eventos tienden a agruparse en ciertas localizaciones).",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "01-introduccion.html#estadística-para-datos-espaciales",
    "href": "01-introduccion.html#estadística-para-datos-espaciales",
    "title": "1  Introducción",
    "section": "1.2 Estadística para datos espaciales",
    "text": "1.2 Estadística para datos espaciales\nCuando los datos recogidos poseen dependencias estrictas (espaciales, temporales, o espacio-temporales), no podemos utilizar técnicas estadísticas convencionales para analizarlos. En efecto, las herramientas de estadística clásica exigen, como condición indispensable, que exista independencia entre los valores observados. Esta norma claramente no se cumple para datos con dependencias. Por ejemplo, en el caso de datos espaciales es muy común que exista alguna relación entre muestras recogidas en ubicaciones cercanas entre sí.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "01-introduccion.html#r-y-su-ecosistema",
    "href": "01-introduccion.html#r-y-su-ecosistema",
    "title": "1  Introducción",
    "section": "1.3 R y su ecosistema",
    "text": "1.3 R y su ecosistema\nEl análisis estadístico de datos es una tarea fundamental en la transformación digital de las empresas y organizaciones. Siempre ha estado ahí, pero en la actualidad la disponibilidad de datos, la cantidad de los mismos, y la velocidad con la que se requieren resultados, está haciendo necesario el capacitar a los profesionales para el análisis de datos con nuevas herramientas. Nuevas tendencias (muchas veces malinterpretadas) como Big Data, Industria 4.0, Internet of Things (IoT), o Data Science, aumentan el interés por parte de las empresas, los profesionales y los investigadores en estas técnicas.\nEl tratamiento de datos y su análisis requiere el uso de software avanzado. Aunque algunas tareas se puede realizar eficazmente con programas de hoja de cálculo como Excel (por ejemplo, son una buena herramienta para mecanizar y almacenar datos), se debería utilizar software especializado para el análisis de datos. Existen distintos paquetes estadísticos comerciales, como SPSS, Statgraphics, Stata, JMP o Minitab (líder en análisis de datos para metodologías de calidad). En los últimos años se ha abierto camino como alternativa el software estadístico y lenguaje de programación R (R Core Team, 2025). Hay otras alternativas que en su mayoría, o son parciales referidas a un ámbito concreto, o son más lenguajes de programación que software estadístico, como Python. R es software libre, pero su gratuidad solo es una de sus ventajas (free as in free beer, and free as in free speech), como se verá a lo largo del curso. El gran inconveniente es la curva de aprendizaje: no es tan fácil de aprender y usar como un software de ventanas, ya que el uso de R se basa en expresiones que hay que ejecutar desde scripts. No obstante, una vez que se tienen las nociones básicas es fácil ir aplicando nuevos métodos.\nR es un sistema para computación estadística: software de análisis de datos y lenguaje de programación. Ha sido ampliamente utilizado en investigación y docencia, y actualmente también en las empresas y organismos públicos. Es la evolución del trabajo de los laboratorios Bell con el lenguaje S (Venables & Ripley, 2002), llevado al mundo del software libre por Ross Ihaka y Robert Gentleman en los años 90 (Ihaka & Gentleman, 1996). La version R 1.0.0 se publicó el 29 de febrero de 2000.\nEn R tenemos numerosos paquetes para representar información geográfica que nos permiten realizar la lectura y escritura de este tipo de datos, llevar a cabo análisis de patrones de puntos y operaciones geoestadísticas. Básicamente existen dos mecanismos para trabajar con datos espaciales:\n\nVectores. En este modelo, el mundo real se representa mediante puntos, líneas, polígonos y combinaciones de todos ellos. Por lo que la información se define mediante pares o ternas de valores. Es decir, los datos vectoriales describen la forma de un objeto y también pueden incluir variables adicionales. Por ejemplo, un conjunto de datos vectoriales puede ser la frontera de las comunidades autónomas de España y, además, puede contener información como el nombre de la comunidad autónoma y su número de habitantes. Este modelo es muy utilizado en el campo de las ciencias sociales porque la información con la que se trabaja tiende a tener fronteras muy bien definidas.\nRáster. Este modelo organiza el espacio como una matriz de celdas de igual tamaño. En cada celda se guarda la información correspondiente a ella. Es decir, cada celda contiene la información de los objetos que están en ella. Se trabaja por capas, agregando características espaciales a una resolución determinada, por lo que resulta muy útil para representar información continua a lo largo de un área. Este modelo es muy utilizado en la cartografía web, en la fotografía aérea y en los dispositivos de teledetección basados en satélites. Por este motivo, en el ámbito de las ciencias ambientales se usa más la filosofía ráster.\n\n\n\n\n\nCressie, N. A. C. (1993). Statistics for Spatial Data. Revised Edition. Wiley. https://doi.org/10.1002/9781119115151\n\n\nIhaka, R., & Gentleman, R. (1996). R: a language for data analysis and graphics. Journal of computational and graphical statistics, 5(3), 299-314.\n\n\nR Core Team. (2025). R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing. https://www.R-project.org/\n\n\nVenables, W. N., & Ripley, B. D. (2002). Modern applied statistics with S. Springer.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "02-datos-espaciales.html",
    "href": "02-datos-espaciales.html",
    "title": "2  Datos espaciales",
    "section": "",
    "text": "2.1 El paquete {sf}\nEn lo que resta del taller, vamos a utilizar (entre otros) los paquetes que cargamos a continuación. Asegúrate de tenerlos instalados antes de continuar con la ejecución del código. Nótese que el paquete {spDataLarge} hay que instalarlo desde un repositorio específico como se indica en la línea comentada. 1",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datos espaciales</span>"
    ]
  },
  {
    "objectID": "02-datos-espaciales.html#el-paquete-sf",
    "href": "02-datos-espaciales.html#el-paquete-sf",
    "title": "2  Datos espaciales",
    "section": "",
    "text": "2.1.1 Introdución\nEl modelo de datos vectoriales se basa en ubicar puntos dentro de un sistema de referencia de coordenadas (CRS). Es decir, dado un CRS, mediante las coordenadas de un punto podemos representar características independientes (por ejemplo, la ubicación de un colegio). También podemos unir estos puntos para obtener formas geométricas más complejas, como líneas y polígonos.\nEn la mayoría de los casos, las geometrías de puntos están definidas en dos dimensiones (X e Y, o latitud y longitud). Si usamos un sistema de tres dimensiones, la tercera dimensión, Z, típicamente representa la altura sobre el nivel del mar.\nEn R podemos encontrar el paquete {sp} que permite trabajar con datos vectoriales proporcionando la información espacial mediante vértices de polígonos. Mediante la función plot() podemos realizar una representación gráfica estática, aunque un tanto limitada. Haciendo uso de los paquetes {tmap}, {ggplot2} y {ggmap} podemos obtener representaciones estáticas mucho más atracticas. También es posible realizar representaciones dinámicas junto con el paquete {leaflet}.\nSin embargo, {sp} se utliza cada vez menos ya que está siendo reemplazado por el paquete {sf}. Este paquete sigue el estandar simple feature definido por la Open Geospatial Consortium (OGC), una organización sin ánimo de lucro cuya principal función es definir estándares para trabajar con datos espaciales. El paquete {sf} proporciona un sistema de clases para datos vectoriales geográficos. Además, tiene una interfaz de línea de comandos consistente para GEOS y GDAL.\n\n\n2.1.2 Simple features\nEl estándar simple features es un modelo común de almacenamiento y acceso para atributos geográficos, creado principalmente para geometrías 2-D (puntos, polígonos, líneas, etc.). Permite conexión con bases de datos geográficas (e.g. PostGIS) y también con Sistemas de Información Geográfica (GIS, por sus siglas), tales como ArcGIS.\nEn R, el paquete sf da soporte para trabajar con datos representados según el estándar simple features. Los registros de datos espaciales se almacenan en un objeto data.frame o tibble con una columna que contiene la información de geometría a representar. Están soportados los 17 tipos de datos representables con simple features en todas las dimensiones. También tiene interfaces con sistemas externos como GEOS, s2geometry, GDAL o PRØJ para realizar multitud de operaciones sobre distintos tipos de objetos y espacios de coordenadas.\nExiste un listado de operaciones soportadas por sf que resume las capacidades completas de este paquete.\nEn particular la función geom_sf() permite incorporar objetos espaciales geométricos gestionados mediante el paquete sf como una capa más de nuestros gráficos creados con ggplot2. También es totalmente compatible con las funciones del paquete dplyr.\nEn sf contamos con diferentes funciones para representar todos los tipos de geometrías vectoriales: puntos, líneas, polígonos y sus respectivas versiones “múltiples” (que agrupan entidades del mismo tipo en una única entidad). Así mismo, podemos agrupar varias geometrías en un solo objeto. También es posible realizar la lectura y escritura de datos a través de una interfaz bastante sencilla.\nEntre otras de las ventajas que ofrece el paquete {sf} podemos destacar:\n\nLos objetos sf son dataframe o tibbles, en los que los datos geográficos se encuentran en la última columna llamada geom o geometry\nLos procesos de lectura y escritura de datos geográficos son rápidos.\nEs posible leer y escribir objetos espaciales en BBDD espaciales como PostGIS.\nLos nombres de las funciones son consistentes e intuitivos, todos ellos empiezan por el prefijo st_\nLas funciones pueden combinarse usando el operador pipe %&gt;% (o |&gt; en R&gt;=4.1.0)\nEs compatible con tidyverse.\n\nR pone a nuestra disposición una amplia documentación de ayuda sobre este paquete que se puede encontrar en https://r-spatial.github.io/sf/index.html, o tecleando vignette(package = \"sf\")en la consola de RStudio2.\n\n\n2.1.3 La clase sfg. Tipos de geometrías\nLa clase sfg da soporte a los diferentes tipos de geometrías simple feature en R: punto, línea, polígono (y sus opciones “múltiples”) o colección de geometrías que constituyen los bloques de construcción básico. Aunque la situación habitual será importar un fichero con datos espaciales, conviene conocer el conjunto de funciones que nos permiten crear objetos geométricos de características simples. A pesar de exitir 17 tipos de geometría, aquí nos vamos a centrar en los siete más utilizados:\n\nPunto: es la geometría base, a partir de ella se construyen las demás. Los puntos son coordenadas en un espacio 2D, 3D o 4D. Si trabajamos en un espacio 3D, la tercera dimensión que añadimos es la altura. En un espacio 4D, la cuarta dimensión es una valor asociado al punto. Para definir un punto usaremos la función st_point(), a la que le pasaremos por parámetro las coordenadas del punto en forma de vector o tabla.\n\n\n# Definición de un punto con 2 dimensiones\npunto &lt;- st_point(c(2.5, 3.75))\nplot(punto, axes = TRUE)\n\n\n\n\n\n\n\n\n\nLínea: cualquier línea se define mediante las coordendas de sus vértices, entiendo por vértice cualquier punto en el que se produzca un cambio de pendiente de la recta, no solo los vértices inicial y final. Para la construcción de líneas contamos con la función st_line()de la clase Linestring. Dicha función espera recibir por parámetro las coordenadas de los vértices de la línea.\n\n\nx1 &lt;- c(0, 3, 5, 8, 10)\ny1 &lt;- c(0, 3, 4, 8, 10)\ncoords1 &lt;- cbind(x1, y1)\nline1 &lt;- st_linestring(coords1)\nplot(line1, axes = TRUE)\n\n\n\n\n\n\n\n\n\nPolígono: Los polígonos se definen mediante las coordenadas de los vértices de una geometría cerrada. Es decir, las coordenadas del primer vértice y el último deben ser las mismas. La clase que da sustento a la construcción de este tipo de objetos es Polygon mediante la función st_polygon(). Esta función espera que le pasemos por parámetro las coordenadas de los vértices de la geometría. Existe un convenio para dar el orden de los vértices. Para definir el contorno del polígono, debemos proporcionar los vértices en el sentido contrario a las agujas del reloj. Sin embargo, para definir un hueco en un polígono, debemos proporcionar los vértices del hueco en el sentido de las agujas del reloj.\n\n\n# Definición de 2 polígonos\n# Sentido contrario agujas del reloj\nx1 &lt;- c(0, 2, 6, 0, 0)\ny1 &lt;- c(4, 4, 10, 10, 4)\ncoords1 &lt;- cbind(x1, y1)\n# Sentido agujas del reloj (hueco)\nx2 &lt;- c(1, 1, 2, 2, 1)\ny2 &lt;- c(5, 6, 6, 5, 5)\ncoords2 &lt;- cbind(x2, y2)\npol &lt;- st_polygon(list(coords1, coords2))\nplot(pol, axes = TRUE)\n\n\n\n\n\n\n\n\n\nMultipunto: es una colección de puntos. Para poder considerar un mutipunto como un objeto sf, todos los puntos que lo componen deben ser diferentes. Podemos definir un multipunto mediante la función st_multipoint() pasándole por parámetro el vector de coordenadas de los puntos.\n\n\n# Definición de varios puntos con 2 dimensiones\ncx &lt;- c(2, 4, 6)\ncy &lt;- c(4, 7, 8)\ncoords &lt;- cbind(cx, cy)\nmpunto &lt;- st_multipoint(coords)\nplot(mpunto, axes = TRUE)\n\n\n\n\n\n\n\n\n\nMultilínea: es una colección de líneas. En la clase Multilinestring encontramos la función st_multilinestring(). Si le pasamos por parámetro una lista de varias líneas, construiremos una multilínea.\n\n\nx2 &lt;- c(2, 1, 1)\ny2 &lt;- c(2, 4, 5)\ncoords2 &lt;- cbind(x2, y2)\nline2 &lt;- st_linestring(coords2)\n\nx3 &lt;- c(8, 8)\ny3 &lt;- c(8, 5)\ncoords3 &lt;- cbind(x3, y3)\nline3 &lt;- st_linestring(coords3)\n\n# Construcción y representación de multilinestring\nlines &lt;- list(line1, line2, line3)\nml &lt;- st_multilinestring(lines)\nplot(ml, axes = TRUE)\n\n\n\n\n\n\n\n\n\nMultipolígono: es una colección de polígonos. Construimos un multipolígono mediante la función st_multipolygon() pasándole una lista con los polígonos que van a formar parte del multipolígono.\n\n\nx1 &lt;- c(0, 2, 6, 0, 0)\ny1 &lt;- c(4, 4, 10, 10, 4)\ncoords1 &lt;- cbind(x1, y1)\npol1 &lt;- st_polygon(list(coords1))\nx2 &lt;- c(0, 1, 1, 0, 0)\ny2 &lt;- c(2, 2, 3, 3, 2)\ncoords2 &lt;- cbind(x2, y2)\npol2 &lt;- st_polygon(list(coords2))\nmpol &lt;- st_multipolygon(list(pol1, pol2))\nplot(mpol, axes =  TRUE)\n\n\n\n\n\n\n\n\n\nColección: un objeto sf también puede ser una colección de geometrías de cualquiera de los tipos vistos, incluidas las opciones multiples.\n\n\n# Colección\ngeometria2 &lt;- st_geometrycollection(list(line1, line3, mpol))\nplot(geometria2, axes = TRUE)\n\n\n\n\n\n\n\n\nComo resumen de esta sección conviene destacar que los objetos sfg se pueden crear a partir de tres tipos de datos básicos:\n\nUn vector numérico (para el caso de un solo punto)\nUna matriz (para el caso de un conjunto de puntos), donde cada fila representa un punto, un multipunto o una cadena de líneas.\nUna lista (para el caso de una colección de objetos como matrices, multilíneas o colecciones de geometría).\n\n\n\n2.1.4 Objetos sfc\nUn objeto sfg solo puede contener geometrías simple feature, mientras que un objeto sfc es una columna simple feature. Es decir, se trata de una lista de objetos sfg, que además puede contener información sobre el sistema de referencia de coordenadas que usan. Usando la función st_sfc() podemos construir objetos sfc a partir de objetos sfg del mismo tipo o de distintos tipos. En la mayoría de los casos, un objeto sfc contendrá objetos del mismo tipo de geometría. Por ejemplo, si convertimos objetos sfg de tipo linestring a un objeto sfc, el resultado es un objeto sfc de tipo linestring.\n\n# Objeto sfc a partir de objetos sfg del mismo tipo -&gt; linestring\ngeom_sfcl &lt;- st_sfc(line1, line3)\ngeom_sfcl\n\nGeometry set for 2 features \nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 0 ymin: 0 xmax: 10 ymax: 10\nCRS:           NA\n\n\nLINESTRING (0 0, 3 3, 5 4, 8 8, 10 10)\n\n\nLINESTRING (8 8, 8 5)\n\nplot(geom_sfcl, axes = TRUE)\n\n\n\n\n\n\n\n\n\n# Objeto sfc a partir de objetos sfg del mismo tipo -&gt; polygon\ngeom_sfcp &lt;- st_sfc(pol1, pol2)\ngeom_sfcp\n\nGeometry set for 2 features \nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 0 ymin: 2 xmax: 6 ymax: 10\nCRS:           NA\n\n\nPOLYGON ((0 4, 2 4, 6 10, 0 10, 0 4))\n\n\nPOLYGON ((0 2, 1 2, 1 3, 0 3, 0 2))\n\nplot(geom_sfcp, axes = TRUE)\n\n\n\n\n\n\n\n\nTambién es posible crear un objeto sfc a partir de objetos sfg de distintos tipos de geometría:\n\n# Objeto sfc a partir de objetos sfg de distinto tipo\ngeom_sfc &lt;- st_sfc(line1, line3, mpol)\ngeom_sfc\n\nGeometry set for 3 features \nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: 0 ymin: 0 xmax: 10 ymax: 10\nCRS:           NA\n\n\nLINESTRING (0 0, 3 3, 5 4, 8 8, 10 10)\n\n\nLINESTRING (8 8, 8 5)\n\n\nMULTIPOLYGON (((0 4, 2 4, 6 10, 0 10, 0 4)), ((...\n\nplot(geom_sfc, axes = TRUE)\n\n\n\n\n\n\n\n# Remarquemos la diferencia con una colección de objetos sfg\ngeom_collection &lt;- st_geometrycollection(list(line1, line3, mpol))\ngeom_collection\n\nGEOMETRYCOLLECTION (LINESTRING (0 0, 3 3, 5 4, 8 8, 10 10), LINESTRING (8 8, 8 5), MULTIPOLYGON (((0 4, 2 4, 6 10, 0 10, 0 4)), ((0 2, 1 2, 1 3, 0 3, 0 2))))\n\nplot(geom_collection, axes = TRUE)\n\n\n\n\n\n\n\n\nComo se ha podido observar en los ejemplos anteriores, el valor predeterminado del sistema de referencia de coordenadas (CRS) es NA. Podemos verificarlo mediante la función st_crs().\n\nst_crs(geom_sfc)\n\nCoordinate Reference System: NA\n\n\nTodas las geometrías de un objeto sfc deben tener el mismo CRS. Podemos especificar el sistema de referencia de coordenadas al construir el objeto mediante el argumento crs de st_sfc().\n\n# Objeto sfc a partir de objetos sfg de distinto tipo y especificamos el CRS\ngeom_sfc_crs &lt;- st_sfc(line1, line3, mpol, crs = \"EPSG:4326\")\nst_crs(geom_sfc_crs)\n\nCoordinate Reference System:\n  User input: EPSG:4326 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n        MEMBER[\"World Geodetic System 1984 (Transit)\"],\n        MEMBER[\"World Geodetic System 1984 (G730)\"],\n        MEMBER[\"World Geodetic System 1984 (G873)\"],\n        MEMBER[\"World Geodetic System 1984 (G1150)\"],\n        MEMBER[\"World Geodetic System 1984 (G1674)\"],\n        MEMBER[\"World Geodetic System 1984 (G1762)\"],\n        MEMBER[\"World Geodetic System 1984 (G2139)\"],\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ENSEMBLEACCURACY[2.0]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n\n\n\n\n2.1.5 La clase sf\nEn las secciones anteriores hemos mostrado como se construyen objetos puramente geométricos, objetos sfg y sfc, que solo almancen información geográfica (coordenadas). A estos objetos podemos agregarles otras características o atributos. Pongamos un ejemplo, vamos a asociarle al punto de Londres una temperatura de 25 °C para el 21 de junio de 2017. Por un lado vamos a tener la geometría (las coordenadas) y, por otro lado, tres atributos con tres clases diferentes (nombre del lugar, temperatura y fecha). Mediante un objeto de la clase sf podemos representar la combinación de estos atributos (data.frame) junto con la columna de geometría (sfc). Para ello contamos con la función st_sf().\n\nlnd_point &lt;- st_point(c(0.1, 51.5))                 # Objeto sfg\nlnd_geom &lt;- st_sfc(lnd_point, crs = 4326)           # Objeto sfc \nlnd_attrib &lt;- data.frame(                           # Objeto data.frame\n  name = \"London\",\n  temperature = 25,\n  date = as.Date(\"2017-06-21\")\n  )\nlnd_sf &lt;- st_sf(lnd_attrib, geometry = lnd_geom)    # Objeto sf\n\nEn el siguiente fragmento de código podemos ver que los objetos sf en realidad tienen dos clases, sf y data.frame. Los objetos sf son data frames, pero con atributos espaciales almacenados en una columna de lista, generalmente llamada geometry. Por este motivo, un objeto sf puede tratarse y se comporta como un data.frame.\n\nlnd_sf\n\nSimple feature collection with 1 feature and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 0.1 ymin: 51.5 xmax: 0.1 ymax: 51.5\nGeodetic CRS:  WGS 84\n    name temperature       date         geometry\n1 London          25 2017-06-21 POINT (0.1 51.5)\n\nclass(lnd_sf)\n\n[1] \"sf\"         \"data.frame\"\n\n\n\n\n2.1.6 Lectura de simple feature\nLos formatos de ficheros de datos espaciales más comunes son shapefile y GEOJSON. El formato shapefile, desarrollado por la compañía ESRI (se dedica a la creacción y comercialización de software para Sistemas de Información Geográfica) es muy utilizado. Sin embargo, GEOJSON se ha centrado sobre todo en aplicaciones del entorno web. GeoPackage (GPKG) es otro formato definido por el Open Geospatial Consortium (OGC).\nEn un fichero shapefile se almacena la localización de elementos geográficos y las características o atributos asociados a ellos, en formato vectorial. Lo constituyen un conjunto de ficheros, entre los que podemos destacar:\n\n.shp: es el archivo que almacena los objetos geométricos\n.shx: es el archivo que almacena el índice de los objetos geométricos\n.dbf: es el archivo que contiene la tabla de los atributos de los objetos geométricos\n.prj: este archivo contiene información del sistema de coordenadas\n\nDesde sf podemos realizar la lectura de un fichero shapefile o GPKG mediante las funciones st_read() o read_sf(). El primer argumento que necesitan estas funciones, es una cadena de texto que contenga la ruta en la que se encuentra el fichero a leer. Desde sf es posible leer muchos tipos de ficheros de datos vectoriales, ya que de forma automática detecta la extensión del archivo y carga los drivers necesarios para interpretar la información que contiene el fichero. A continuación podremos realizar una simple representación estática mediante la función plot().\n\nvector_filepath &lt;- system.file(\"shapes/world.gpkg\", package = \"spData\")\nworld &lt;- read_sf(vector_filepath, quiet = TRUE)\n# Equivalente a: world &lt;- st_read(vector_filepath, as_tibble = TRUE)\nplot(world)\n\nWarning: plotting the first 9 out of 10 attributes; use max.plot = 10 to plot\nall\n\n\n\n\n\n\n\n\n\nEstas funciones también permiten leer solo partes de un archivo en la RAM. A continuación mostramos un par de ejemplos de como leer una porción de un archivo y una sola línea mediante el empleo de una consulta SQL. En el primer caso, a través de la consulta le indicamos que queremos obtener todas las columnas (SELECT *) de la capa “world” para la cual continent es igual a “Europe”. En el segundo caso, nos quedamos solo con la capa correspondiente a name_long = \"Spain\":\n\n# Podemos seleccionar un continente\neurope &lt;- st_read(vector_filepath,\n                  query = 'SELECT * FROM \"world\" WHERE continent = \"Europe\"')\n\nReading query `SELECT * FROM \"world\" WHERE continent = \"Europe\"'\nfrom data source `/home/jfelipe/R/x86_64-pc-linux-gnu-library/4.5/spData/shapes/world.gpkg' \n  using driver `GPKG'\nSimple feature collection with 39 features and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: 2.053389 xmax: 180 ymax: 81.2504\nGeodetic CRS:  WGS 84\n\nhead(europe)\n\nSimple feature collection with 6 features and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: 2.053389 xmax: 180 ymax: 81.2504\nGeodetic CRS:  WGS 84\n  iso_a2          name_long continent region_un       subregion\n1     RU Russian Federation    Europe    Europe  Eastern Europe\n2     NO             Norway    Europe    Europe Northern Europe\n3     FR             France    Europe    Europe  Western Europe\n4     SE             Sweden    Europe    Europe Northern Europe\n5     BY            Belarus    Europe    Europe  Eastern Europe\n6     UA            Ukraine    Europe    Europe  Eastern Europe\n               type   area_km2       pop  lifeExp gdpPercap\n1 Sovereign country 17018507.4 143819666 70.74366 25284.586\n2 Sovereign country   397994.6        NA       NA        NA\n3           Country   644847.9        NA       NA        NA\n4 Sovereign country   450581.6   9696110 82.25366 44167.632\n5 Sovereign country   208969.8   9474511 72.97073 17944.210\n6 Sovereign country   572549.0  45271947 71.18659  8243.474\n                            geom\n1 MULTIPOLYGON (((180 70.8322...\n2 MULTIPOLYGON (((15.14282 79...\n3 MULTIPOLYGON (((-51.6578 4....\n4 MULTIPOLYGON (((11.02737 58...\n5 MULTIPOLYGON (((28.17671 56...\n6 MULTIPOLYGON (((35.01266 45...\n\nplot(europe)\n\n\n\n\n\n\n\n# Podemos seleccionar un pais\nspain &lt;- read_sf(vector_filepath,\n                 query = 'SELECT * FROM \"world\" WHERE name_long = \"Spain\"')\nhead(spain)\n\nSimple feature collection with 1 feature and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -9.392884 ymin: 35.94685 xmax: 3.039484 ymax: 43.74834\nGeodetic CRS:  WGS 84\n# A tibble: 1 × 11\n  iso_a2 name_long continent region_un subregion   type  area_km2    pop lifeExp\n  &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;    &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;\n1 ES     Spain     Europe    Europe    Southern E… Sove…  502306. 4.65e7    83.2\n# ℹ 2 more variables: gdpPercap &lt;dbl&gt;, geom &lt;MULTIPOLYGON [°]&gt;\n\nplot(spain)\n\nWarning: plotting the first 9 out of 10 attributes; use max.plot = 10 to plot\nall\n\n\n\n\n\n\n\n\n\n\n\n2.1.7 Representación estática\nLos mapas básicos se crean en sf con plot(). Por defecto, esta opción crea un gráfico de varios paneles, en los que, cada panel contiene un gráfico secundario correspondiente a la representación de una variable del objeto. Si la variable que se está representando en un panel es continua, se incluirá por defecto una leyenda o “clave” con un color continuo si el objeto a trazar tiene una sola variable. Los colores también se pueden configurar con col=, aunque esto no creará una paleta continua o una leyenda. Utilizamos ahora los datos de países del paquete {rnaturalearth}.\n\nworld &lt;- ne_countries(scale = \"medium\", returnclass = \"sf\")\nclass(world)\n\n[1] \"sf\"         \"data.frame\"\n\nnames(world)\n\n  [1] \"featurecla\" \"scalerank\"  \"labelrank\"  \"sovereignt\" \"sov_a3\"    \n  [6] \"adm0_dif\"   \"level\"      \"type\"       \"tlc\"        \"admin\"     \n [11] \"adm0_a3\"    \"geou_dif\"   \"geounit\"    \"gu_a3\"      \"su_dif\"    \n [16] \"subunit\"    \"su_a3\"      \"brk_diff\"   \"name\"       \"name_long\" \n [21] \"brk_a3\"     \"brk_name\"   \"brk_group\"  \"abbrev\"     \"postal\"    \n [26] \"formal_en\"  \"formal_fr\"  \"name_ciawf\" \"note_adm0\"  \"note_brk\"  \n [31] \"name_sort\"  \"name_alt\"   \"mapcolor7\"  \"mapcolor8\"  \"mapcolor9\" \n [36] \"mapcolor13\" \"pop_est\"    \"pop_rank\"   \"pop_year\"   \"gdp_md\"    \n [41] \"gdp_year\"   \"economy\"    \"income_grp\" \"fips_10\"    \"iso_a2\"    \n [46] \"iso_a2_eh\"  \"iso_a3\"     \"iso_a3_eh\"  \"iso_n3\"     \"iso_n3_eh\" \n [51] \"un_a3\"      \"wb_a2\"      \"wb_a3\"      \"woe_id\"     \"woe_id_eh\" \n [56] \"woe_note\"   \"adm0_iso\"   \"adm0_diff\"  \"adm0_tlc\"   \"adm0_a3_us\"\n [61] \"adm0_a3_fr\" \"adm0_a3_ru\" \"adm0_a3_es\" \"adm0_a3_cn\" \"adm0_a3_tw\"\n [66] \"adm0_a3_in\" \"adm0_a3_np\" \"adm0_a3_pk\" \"adm0_a3_de\" \"adm0_a3_gb\"\n [71] \"adm0_a3_br\" \"adm0_a3_il\" \"adm0_a3_ps\" \"adm0_a3_sa\" \"adm0_a3_eg\"\n [76] \"adm0_a3_ma\" \"adm0_a3_pt\" \"adm0_a3_ar\" \"adm0_a3_jp\" \"adm0_a3_ko\"\n [81] \"adm0_a3_vn\" \"adm0_a3_tr\" \"adm0_a3_id\" \"adm0_a3_pl\" \"adm0_a3_gr\"\n [86] \"adm0_a3_it\" \"adm0_a3_nl\" \"adm0_a3_se\" \"adm0_a3_bd\" \"adm0_a3_ua\"\n [91] \"adm0_a3_un\" \"adm0_a3_wb\" \"continent\"  \"region_un\"  \"subregion\" \n [96] \"region_wb\"  \"name_len\"   \"long_len\"   \"abbrev_len\" \"tiny\"      \n[101] \"homepart\"   \"min_zoom\"   \"min_label\"  \"max_label\"  \"label_x\"   \n[106] \"label_y\"    \"ne_id\"      \"wikidataid\" \"name_ar\"    \"name_bn\"   \n[111] \"name_de\"    \"name_en\"    \"name_es\"    \"name_fa\"    \"name_fr\"   \n[116] \"name_el\"    \"name_he\"    \"name_hi\"    \"name_hu\"    \"name_id\"   \n[121] \"name_it\"    \"name_ja\"    \"name_ko\"    \"name_nl\"    \"name_pl\"   \n[126] \"name_pt\"    \"name_ru\"    \"name_sv\"    \"name_tr\"    \"name_uk\"   \n[131] \"name_ur\"    \"name_vi\"    \"name_zh\"    \"name_zht\"   \"fclass_iso\"\n[136] \"tlc_diff\"   \"fclass_tlc\" \"fclass_us\"  \"fclass_fr\"  \"fclass_ru\" \n[141] \"fclass_es\"  \"fclass_cn\"  \"fclass_tw\"  \"fclass_in\"  \"fclass_np\" \n[146] \"fclass_pk\"  \"fclass_de\"  \"fclass_gb\"  \"fclass_br\"  \"fclass_il\" \n[151] \"fclass_ps\"  \"fclass_sa\"  \"fclass_eg\"  \"fclass_ma\"  \"fclass_pt\" \n[156] \"fclass_ar\"  \"fclass_jp\"  \"fclass_ko\"  \"fclass_vn\"  \"fclass_tr\" \n[161] \"fclass_id\"  \"fclass_pl\"  \"fclass_gr\"  \"fclass_it\"  \"fclass_nl\" \n[166] \"fclass_se\"  \"fclass_bd\"  \"fclass_ua\"  \"geometry\"  \n\n# head(world) # Descomentar para imprimir vista inicial\nplot(world[3:6])\n\n\n\n\n\n\n\nplot(world[\"pop_est\"])\n\n\n\n\n\n\n\n\nEn ocasiones resulta útil representar solo una porción del data frame original.\n\nworld_asia &lt;- world[world$continent == \"Asia\", ]\n# head(world_asia) # Descomentar para imprimir vista\nplot(world_asia)\n\nWarning: plotting the first 9 out of 168 attributes; use max.plot = 168 to plot\nall\n\n\n\n\n\n\n\n\nplot(world_asia[\"pop_est\"])\n\n\n\n\n\n\n\n\nEn el siguiente ejemplo mostramos como destacar un pais sobre este continente.\n\nindia &lt;- world[world$name_long == \"India\", ]\nplot(st_geometry(india), \n     expandBB = c(0, 0.2, 0.1, 1), \n     col = \"gray\", \n     lwd = 3)\nplot(world_asia[0], add = TRUE)\n\n\n\n\n\n\n\n\nLa función plot() es rápida de ejecutar y requiere pocas líneas de código. Sin embargo, las gráficas que genera son un tanto simples. Podemos conseguir representaciones estáticas mucho más elaboradas si usamos la función geom_sf() del paquete {ggplot2}.\n\nggplot(data = world) +\n  geom_sf(aes(fill = pop_est)) +\n  scale_fill_gradient(low = \"lightblue\", high = \"blue\")",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datos espaciales</span>"
    ]
  },
  {
    "objectID": "02-datos-espaciales.html#datos-raster-y-cubos-de-datos-vectoriales",
    "href": "02-datos-espaciales.html#datos-raster-y-cubos-de-datos-vectoriales",
    "title": "2  Datos espaciales",
    "section": "2.2 Datos raster y cubos de datos vectoriales",
    "text": "2.2 Datos raster y cubos de datos vectoriales\n\nEl paquete stars ofrece soporte para representación y manejo de datos raster (por ejemplo, de imágenes satelitales) así como cubos de datos vectoriales (vector datacubes), tal y como muestra la Figura 2.1.\n\n\n\n\n\n\n\nFigura 2.1: Los hipercubos de datos son cubos de varias dimensiones que pueden contener datos de: latitud y longitud, tiempo, distintas bandas y diferentes sensores. Fuente: https://r-spatial.github.io/stars/.\n\n\n\n\nEl paquete terra incluye numerosas herramientas para procesado y análisis de datos espaciales, incluyendo manipulación de objetos raster.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datos espaciales</span>"
    ]
  },
  {
    "objectID": "02-datos-espaciales.html#el-paquete-terra",
    "href": "02-datos-espaciales.html#el-paquete-terra",
    "title": "2  Datos espaciales",
    "section": "2.3 El paquete {terra}",
    "text": "2.3 El paquete {terra}\n\n2.3.1 Introdución\nEl modelo de datos ráster se utiliza comúnmente para representar fenómenos espacialmente continuos como, por ejemplo, la temperatura o la densidad de población. Este modelo represetna el mundo real mediante una cuadrícula de rectángulos de igual tamaño (denominados celdas o, en el contexto de la teledetección por satélite, píxeles).\nGeneralmente, los datos raster constan de un encabezado y una matriz (con filas y columnas) cuyas celdas están igualmente espaciadas. El encabezado define el sistema de referencia de coordenadas, la extensión y el origen. Lo habitual es que el origen (o punto de partida) sea la coordenada de la esquina inferior izquierda de la matriz, aunque algunos paquetes, como el paquete {terra}, designan para este fin la esquina superior izquierda. El encabezado define la extensión a través del número de columnas, el número de filas y la resolución del tamaño de celda. Por lo tanto, comenzando desde el origen, podemos acceder fácilmente y modificar cada celda usando el ID de una celda o especificando explícitamente las filas y columnas.\nLa principal ventaja de esta representación matricial es que evita almacenar explícitamente las coordenadas de las cuatro esquinas (de hecho, solo almacena una coordenada, la del origen) de cada celda, a diferencia del caso de los polígonos vectoriales rectangulares. Ésto, junto con el álgebra de mapas, hacen que el procesamiento de ráster sea mucho más eficiente y rápido que el procesamiento de datos vectoriales. Sin embargo, a diferencia de los datos vectoriales, la celda de una capa ráster solo puede contener un valor, que puede ser numérico o categórico.\n\n\n\n\n\n\nFigura 2.2: Figura tomada de (Lovelace et al., 2019), sección 2.3.\n\n\n\nAunque el modelo de datos ráster se utiliza para representar fenómenos continuos, también es posible representar características discretas como el suelo o las clases de cobertura terrestre, la única diferencia es que, en este caso, los bordes discretos de estas características se vuelven borrosos. En general, cuando se trabaja con características discretas, resulta mucho más adecuada una representación vectorial.\n\n\n\n\n\n\nFigura 2.3: Figura tomada de (Lovelace et al., 2019), sección 2.3.\n\n\n\nR cuenta con varios paquetes capaces de leer y procesar datos ráster, siendo los más utilizados {terra} y {stars}. En este curso, nos centramos en el paquete {terra}. Como características principales podemos destacar:\n\nFue creado por Robert Hijmans, al igual que su predecesor, el paquete {raster}.\nTrabaja con el modelo de datos ráster de cuadrículas regulares.\nPuede manejar rasters de una o varias capas, teniendo en cuenta que todos los elementos deben tener las mismas dimensiones espaciales y extensión.\nPuede leer datos ráster en la memoria o simplemente leer sus metadatos. Generalmente, esta operación se hace automáticamente en función del tamaño del archivo de entrada.\nUsa su propia clase de objetos para datos vectoriales, llamada SpatVector.\n\nEl paquete {terra} ofrece un amplio conjunto de funciones para crear, leer, exportar, manipular y procesar datasets ráster. Su funcionalidad, en gran medida, es la misma que la del paquete {raster}, pero con la ventaja añadida de que las funciones de {terra} suelen ser más eficientes, desde el punto de vista computacional, que sus equivalentes en {raster}. Al igual que con {sf} y {sp}, se pueden realizar traducciones sin problemas entre los dos tipos de objetos para garantizar la compatibilidad con versiones anteriores.\n\n\n2.3.2 SpatRaster\nA diferencia de los datos vectoriales, en los datos ráster la geometría no se almacena explícitamente como coordenadas. Se establece implícitamente conociendo la extensión espacial y el número de filas y columnas en las que se divide el área. A partir de la extensión y el número de filas y columnas, se puede calcular el tamaño de las celdas ráster (resolución espacial). Si bien las celdas ráster se pueden considerar como un conjunto de polígonos regulares, sería muy ineficiente representar los datos de esa manera, ya que las coordenadas de cada celda tendrían que almacenarse explícitamente. Hacerlo también aumentaría drásticamente el tiempo de procesamiento.\nVamos a ver un ejemplo de creación de un objeto SpatRaster desde cero, aunque lo normal es crear estos objetos a partir de un archivo.\n\n# Indicamos numero de columnas, filas y extension\nr &lt;- rast(ncol = 10, nrow = 10, \n          xmin = 10, xmax = 70, \n          ymin = 10, ymax = 50)\nr\n\nclass       : SpatRaster \nsize        : 10, 10, 1  (nrow, ncol, nlyr)\nresolution  : 6, 4  (x, y)\nextent      : 10, 70, 10, 50  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \n\n# ¿¿¿Que ocurre???\nplot(r)\n\n\n\n\n\n\n\n\nComo puede observarse, el objeto r solo tiene la geometría de un conjunto de datos ráster. Es decir, le hemos proporcionado una ubicación y resolución, pero no tiene valores asociados. Vamos a asignarle algunos valores. Para ello generamos ncell valores aleatorios a partir de una distribución uniforme y se los asignamos a nuestro ráster r mediante la función values().\n\n# Asignación de valores\nvalues(r) &lt;- runif(ncell(r))\nr\n\nclass       : SpatRaster \nsize        : 10, 10, 1  (nrow, ncol, nlyr)\nresolution  : 6, 4  (x, y)\nextent      : 10, 70, 10, 50  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \nsource(s)   : memory\nname        :       lyr.1 \nmin value   : 0.002841152 \nmax value   : 0.988144838 \n\nplot(r)\n\n\n\n\n\n\n\n\nUna forma sencilla de crear un objeto multi-layer es utilizando el método c(). Al representar el ráster multi-layer, obtendremos una gráfica por cada capa.\n\nr2 &lt;- r * r\nr3 &lt;- sqrt(r)\nr4 &lt;- r + r\ns &lt;- c(r, r2, r3, r4)\ns\n\nclass       : SpatRaster \nsize        : 10, 10, 4  (nrow, ncol, nlyr)\nresolution  : 6, 4  (x, y)\nextent      : 10, 70, 10, 50  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \nsource(s)   : memory\nnames       :       lyr.1,        lyr.1,      lyr.1,       lyr.1 \nmin values  : 0.002841152, 8.072146e-06, 0.05330246, 0.005682305 \nmax values  : 0.988144838, 9.764302e-01, 0.99405475, 1.976289675 \n\nplot(s)\n\n\n\n\n\n\n\n\nCuando añadimos varias capas, es conveniente darles un nombre diferente mediante la función names().\n\nnames(s) &lt;- c('layer1', 'layer2', 'layer3', 'layer4')\ns\n\nclass       : SpatRaster \nsize        : 10, 10, 4  (nrow, ncol, nlyr)\nresolution  : 6, 4  (x, y)\nextent      : 10, 70, 10, 50  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \nsource(s)   : memory\nnames       :      layer1,       layer2,     layer3,      layer4 \nmin values  : 0.002841152, 8.072146e-06, 0.05330246, 0.005682305 \nmax values  : 0.988144838, 9.764302e-01, 0.99405475, 1.976289675 \n\nplot(s)\n\n\n\n\n\n\n\n\nOtras funciones interesantes a la hora de construir nuestro propio ráster o de tabajar con objetos ráster son:\n\nncol(): indica el número de columnas\nnrow() indica el número de filas\nncell(): indica el número de celdas\nres(): indica la resolución en X e Y\ndim(): indica la dimensión (número de columnas, filas y capas)\n\n\nncol(s) \n\n[1] 10\n\nnrow(s)\n\n[1] 10\n\nncell(s)\n\n[1] 100\n\nres(s)\n\n[1] 6 4\n\ndim(s)\n\n[1] 10 10  4\n\n\nPara más información, podeís consultar la documentación oficial o la ayuda de RStudio.\n\n\n2.3.3 Lectura de datos raster\nAl igual que los datos vectoriales, los datos ráster vienen en muchos formatos de archivo y algunos de ellos admiten archivos multicapa. Uno de estos formatos es el archivo de imagen TIF. La función rast() de {terra} nos permite leer ficheros de datos ráster tanto de una capa como de varias. Veamos algunos ejemplos usando los datasets de {spDataLarge}.\n\n# Fichero raster de 1 capa\nraster_filepath &lt;- system.file(\"raster/srtm.tif\", \n                               package = \"spDataLarge\")\nsingle_layer &lt;- rast(raster_filepath)\nsingle_layer\n\nclass       : SpatRaster \nsize        : 457, 465, 1  (nrow, ncol, nlyr)\nresolution  : 0.0008333333, 0.0008333333  (x, y)\nextent      : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : srtm.tif \nname        : srtm \nmin value   : 1024 \nmax value   : 2892 \n\nplot(single_layer)\ntitle(main = \"Zion National Park\")\n\n\n\n\n\n\n\n\n\n# Fichero raster de 4 capas\nmultilayer_filepath &lt;- system.file(\"raster/landsat.tif\", \n                                   package = \"spDataLarge\")\nmultilayer_rast &lt;- rast(multilayer_filepath)\nmultilayer_rast\n\nclass       : SpatRaster \nsize        : 1428, 1128, 4  (nrow, ncol, nlyr)\nresolution  : 30, 30  (x, y)\nextent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / UTM zone 12N (EPSG:32612) \nsource      : landsat.tif \nnames       : landsat_1, landsat_2, landsat_3, landsat_4 \nmin values  :      7550,      6404,      5678,      5252 \nmax values  :     19071,     22051,     25780,     31961 \n\nplot(multilayer_rast)\n\n\n\n\n\n\n\n\n\n\n2.3.4 Representación estática\nAunque ya hemos mostrado algún ejemplo de representación gráfica, en esta sección completaremos algunos aspectos más sobre este tema. Vamos a trabajar con el dataset de Luxemburgo del paquete {terra}. Empezaremos realizando una representación sencilla de la geometría, que creamos con la función vect().\n\nfilename &lt;- system.file(\"ex/lux.shp\", \n                        package = \"terra\")\nbasename(filename)\n\n[1] \"lux.shp\"\n\nraster_file &lt;- vect(filename)\nraster_file\n\n class       : SpatVector \n geometry    : polygons \n dimensions  : 12, 6  (geometries, attributes)\n extent      : 5.74414, 6.528252, 49.44781, 50.18162  (xmin, xmax, ymin, ymax)\n source      : lux.shp\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       :  ID_1   NAME_1  ID_2   NAME_2  AREA       POP\n type        : &lt;num&gt;    &lt;chr&gt; &lt;num&gt;    &lt;chr&gt; &lt;num&gt;     &lt;num&gt;\n values      :     1 Diekirch     1 Clervaux   312 1.808e+04\n                   1 Diekirch     2 Diekirch   218 3.254e+04\n                   1 Diekirch     3  Redange   259 1.866e+04\n\nplot(raster_file)\n\n\n\n\n\n\n\n\nAl contener información sobre varias variables, podemos elegir qué variable queremos ver representada sobre la geometría. Por ejemplo, vamos a representar los valores de población y de área.\n\nlibrary(\"viridis\")\n\nCargando paquete requerido: viridisLite\n\n# Representación de una variable\nplot(raster_file, \"POP\")\n\n\n\n\n\n\n\n# Representación de varias variables\nplot(raster_file, c(\"POP\", \"AREA\"), col = viridis(10))\n\n\n\n\n\n\n\n\nTambién podemos hacer una matriz de figuras con la función par() y representar las gráficas ajustando el espaciado, colocando las leyendas dentro del área del mapa y poniendo el texto del eje Y en horizontal.\n\npar(mfrow = c(1,2))\nm &lt;- c(3.1, 3.1, 2.1, 2.1)\nplot(raster_file, \"POP\", col = viridis(10), mar = m, \n     plg = list(x = \"topright\"), \n     pax = list(las = 1))\nplot(raster_file, \"AREA\", col = viridis(10), mar = m, \n     plg = list(x = \"topright\", cex=.75),\n     pax = list(las = 1))\n\n\n\n\n\n\n\n\nLa visualización predeterminada de un SpatRaster de una sola capa depende del tipo de datos, pero siempre habrá una leyenda.\n\npar(mfrow = c(1, 1))\nf &lt;- system.file(\"ex/elev.tif\", \n                 package = \"terra\")\nr &lt;- rast(f)\nr\n\nclass       : SpatRaster \nsize        : 90, 95, 1  (nrow, ncol, nlyr)\nresolution  : 0.008333333, 0.008333333  (x, y)\nextent      : 5.741667, 6.533333, 49.44167, 50.19167  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : elev.tif \nname        : elevation \nmin value   :       141 \nmax value   :       547 \n\nplot(r)\n\n\n\n\n\n\n\n\nPodemos realizar un tipo diferente de representación, por ejemplo, por intervalos.\n\nm &lt;- c(3.1, 3.1, 1.1, 1.1)\nplot(r, type = \"interval\", \n     plg = list(x = \"topright\"), \n     mar = m)",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datos espaciales</span>"
    ]
  },
  {
    "objectID": "02-datos-espaciales.html#datos-de-españa",
    "href": "02-datos-espaciales.html#datos-de-españa",
    "title": "2  Datos espaciales",
    "section": "2.4 Datos de España",
    "text": "2.4 Datos de España\nTenemos la enorme suerte de que en nuestro país existe una comunidad muy activa que desarrolla múltiples paquetes R con información cartográfica, datos climáticos y de otra índole, ya preparados y perfectamente integrados con el resto de paquetes populares como ggplot2. Destacan:\n\nmapSpain: facilita la creación de mapas a diferentes niveles administrativos de España. Incluye muchas herramientas, como por ejemplo una función para representar las regiones como cuadrados o hexágonos de forma esquemática, siguiendo una idea parecida a los gráficos creados por el paquete statebins. Estos son una alternativa simplificada a los mapas de coropletas.\nclimaemet: permite utilizar la API de datos de la AEMET, integrándolos de forma directa en nuestro flujo de trabajo con R. Es imprescindible conseguir previamente una API KEY\n\n\n# Instala los paquetes sf y climaemet previamente\n\n# Ejecuta una sola vez para obtener tu API key:\n# aemet_api_key(apikey, overwrite = FALSE, install = FALSE)\n\nlibrary(climaemet)\nlibrary(ggplot2)\nlibrary(dplyr)\n\nall_stations &lt;- aemet_daily_clim(\n  start = \"2021-01-08\", end = \"2021-01-08\",\n  return_sf = TRUE\n)\n\nggplot(all_stations) +\n  geom_sf(aes(colour = tmed), shape = 19, size = 2, alpha = 0.95) +\n  labs(\n    title = \"Average temperature in Spain\",\n    subtitle = \"8 Jan 2021\",\n    color = \"Max temp.\\n(celsius)\",\n    caption = \"Source: AEMET\"\n  ) +\n  scale_colour_gradientn(\n    colours = hcl.colors(10, \"RdBu\", rev = TRUE),\n    breaks = c(-10, -5, 0, 5, 10, 15, 20),\n    guide = \"legend\"\n  ) +\n  theme_bw() +\n  theme(\n    panel.border = element_blank(),\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\")\n  )\n\n\n\n\n\n\n\nFigura 2.4: Representación de la temperatura máxima en distintos puntos de España en un día (2021-01-08). Fuente: https://ropenspain.github.io/climaemet/.\n\n\n\n\nairqualityES: datos diarios de medidas de calidad del aire en España en un periodo de 18 años (2001-2018), incluyendo varios agentes contaminantes. Los datos son publicados por el Gobierno de España en abierto.\n\n\n\n\n\nLovelace, R., Nowosad, J., & Muenchow, J. (2019). Geocomputation with R. Chapman; Hall/CRC.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datos espaciales</span>"
    ]
  },
  {
    "objectID": "02-datos-espaciales.html#footnotes",
    "href": "02-datos-espaciales.html#footnotes",
    "title": "2  Datos espaciales",
    "section": "",
    "text": "El resto se pueden instalar desde CRAN usando el panel Packages de RStudio o la función install.packages con el repositorio por defecto. Algunos paquetes tienen muchas dependencias y pueden tardar. Si después de la instalación alguno de los paquetes no se carga, comprueba que en la instalación no se produjeron errores.↩︎\nUna versión mejor de las viñetas, como indica el autor, se encuentran en https://r-spatial.github.io/sf/articles/↩︎",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datos espaciales</span>"
    ]
  },
  {
    "objectID": "03-visualizacion-basica.html",
    "href": "03-visualizacion-basica.html",
    "title": "3  Visualización básica",
    "section": "",
    "text": "3.1 Datos de ejemplo\nEn este capítulo presentamos algunas herramientas básicas de visualización en R, que se pueden aplicar a la creación de gráficos con datos espaciales.\nUsaremos un dataset de ejemplo de un completo libro sobre métodos de regresión, ya en su segunda edición (Fahrmeir et al., 2022). Los archivos con los datasets de ejemplo de esta referencia se pueden descargar de su página web, así como también los archivos de código con los modelos sobre estos datos, en R.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Visualización básica</span>"
    ]
  },
  {
    "objectID": "03-visualizacion-basica.html#el-paquete-ggplot2",
    "href": "03-visualizacion-basica.html#el-paquete-ggplot2",
    "title": "3  Visualización básica",
    "section": "3.2 El paquete ggplot2",
    "text": "3.2 El paquete ggplot2\n\n3.2.1 Anatomía de un gráfico con ggplot2\nEl paquete ggplot2 sigue los principios de la gramática de gráficos (véase el capítulo 4 de nuestro taller previo sobre visualización), de forma que nos permite construir un gráfico paso a paso. Para ello se empieza por utilizar la función ggplot():\n\nIndicamos a la función ggplot() los datos que vamos a representar. \nIndicamos a ggplot() qué relaciones queremos visualizar. \nElegimos cómo queremos representar gráficamente las relaciones en nuestros datos que hemos indicado en el paso anterior. \nSi es necesario, superponemos más elementos gráficos (objetos geométricos o geoms), añadiéndolas a nuestro gráfico una a una.\nIncluimos funciones adicionales para ajustar transformar los datos, ajustar o cambiar escalas, añadir etiquetas y título, marcas en los ejes, capas adicionales, etc.\n\nEl argumento data = ....El argumento mapping = aes(...).Elegimos una función geom_...() que determina el tipo de gráfico o elemento gráfico.Veamos estós datos sobre un esquema para hacernos una idea más clara del aspecto que tendrá nuestro código.\n1ggplot(data = &lt;DATOS&gt;,\n       mapping = aes(&lt;CONEXIONES&gt;)) +\n2  geom_...(...) +\n3  stat_...(...) +\n4  &lt;FUNCIONES DE ESCALA Y GUÍAS&gt; +\n5  &lt;SISTEMAS COORDENADOS&gt; +\n6  &lt;FACETAS&gt; +\n7  &lt;TEMA&gt;\n\n1\n\nIndicamos qué datos vamos a utilizar y como conectamos esos datos (mapeo) con los elementos estéticos. Esta parte es obligatoria.\n\n2\n\nAñadimos uno o varios objetos geométricos para representar los datos.\n\n3\n\nTransformamos los datos (funciones stat_...()), normalmente resumiéndolos de algún modo.\n\n4\n\nAjustamos el mapeo de los datos a los elementos estéticos, modificando la escala de representación o añadiendo elementos de guía para intepretar el gráfico (marcas en ejes, leyenda, etc.).\n\n5\n\nConfiguramos el sistema coordenado de representación (por defecto se usan coordenadas cartesianas): intercambio de ejes X e Y (función coord_flip()), uso de coordenadas polares (coord_polar()), etc.\n\n6\n\nDecidimos si queremos desglosar el gráfico en varios paneles (facets) para presentar simultáneamente varios subgráficos (como hemos visto, útil para comparar entre grupos, evolución temporal y en otros casos).\n\n7\n\nPor último, podemos elegir un tema preconfigurado que adapta el aspecto de muchos de los elementos del gráfico para conseguir un resultado final más armonizado.\n\n\n\n\n\n\n\n\nInformación adicional sobre ggplot2\n\n\n\n\n\nSi necesitas más información sobre la utilización del paquete ggplot2 te recomendamos que consultes las siguientes referencias:\n\nCapítulo 5 de nuestro curso previo Visualización de Datos con R, para este mismo programa de doctorado.\nManual oficial de ggplot2: https://ggplot2-book.org (3ª ed., en progreso).\n\n\n\n\n\n\n3.2.2 Ejemplo básico de representación\n\nlibrary(ggplot2)\nlibrary(Hmisc)\n\n\nAdjuntando el paquete: 'Hmisc'\n\n\nThe following objects are masked from 'package:base':\n\n    format.pval, units\n\nlibrary(readr)\n\n# Lectura de datos; consulta la explicación en el capítulo 7\nbeech &lt;- read_table(\"data/beech.raw\",\n  col_types = cols(id = col_integer(), year = col_integer(), age = col_integer(),\n                   canopyd = col_integer(), gradient = col_integer(),\n                   alt = col_integer(), depth = col_integer(), ph = col_double(),\n                   watermoisture = col_factor(levels = c(\"1\", \"2\", \"3\")),\n                   alkali = col_factor(levels = c(\"1\",\"2\", \"3\", \"4\")),\n                   humus = col_factor(levels = c(\"0\", \"1\", \"2\", \"3\", \"4\",\n                                                 \"5\", \"6\", \"7\", \"8\", \"9\")),\n                   type = col_factor(levels = c(\"0\",\"1\")),\n                   fert = col_factor(levels = c(\"0\",\"1\"))\n                   ))\n\nbeech_years &lt;- beech |&gt;\n               dplyr::filter(year == 2004)\n\np_beech &lt;- ggplot(data = beech_years,\n                  aes(x = x, y = y,\n                      color = defol, size = age)) +\n           geom_point(alpha = 0.6) +\n           labs(title = \"Bosque the Rothenbuch (Spessart)\",\n                subtitle = \"Axel Göttlein (Tech. Univ., Munich). Año: 2004.\") +\n           theme(\n            legend.text = element_text(size = 12),\n            legend.title = element_text(size = 14),\n            strip.text = element_text(size = 12),\n            axis.text = element_text(size = 12),\n            axis.title = element_text(size = 14),\n           )\np_beech\n\n\n\n\n\n\n\nFigura 3.1: Visualización utilizando dos canales y facetas.\n\n\n\n\n\n\n\n3.2.3 Mapas estáticos\n\n\n\n\nFahrmeir, L., Kneib, T., Lang, S., & Marx, B. D. (2022). Regression: Models, Methods and Applicatons (2.ª ed.). Springer-Verlag GmbH. https://doi.org/10.1007/978-3-662-63882-8",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Visualización básica</span>"
    ]
  },
  {
    "objectID": "04-visualizacion-avanzada.html",
    "href": "04-visualizacion-avanzada.html",
    "title": "4  Visualización avanzada",
    "section": "",
    "text": "4.1 Mapas cartográficos\nDominic Royé ha creado recientemente un taller titulado Breve introducción a la cartografía con R, que muestra algunos ejemplos básicos sobre cómo manejar este tipo de datos.",
    "crumbs": [
      "Visualización avanzada",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualización avanzada</span>"
    ]
  },
  {
    "objectID": "04-visualizacion-avanzada.html#mapas-cartográficos",
    "href": "04-visualizacion-avanzada.html#mapas-cartográficos",
    "title": "4  Visualización avanzada",
    "section": "",
    "text": "Figura 4.1: Representación gráfica de la red de ríos de la cuenca hidrográfica del Ebro. El grosor de línea se corresponde con el caudal promedio de cada río. Fuente: https://github.com/dominicroye/Taller_Carto_RqueR_2024.\n\n\n\n\n\n\n\n\n\nFigura 4.2: Modelo digital del terreno (MDT) de Suiza. Se ha añadido efecto de sombreado para interpretar mejor el relieve de cada zona. Fuente: https://github.com/dominicroye/Taller_Carto_RqueR_2024.",
    "crumbs": [
      "Visualización avanzada",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualización avanzada</span>"
    ]
  },
  {
    "objectID": "05-mapas-interactivos.html",
    "href": "05-mapas-interactivos.html",
    "title": "5  Mapas interactivos",
    "section": "",
    "text": "5.0.1 Paquetes necesarios\nExisten un gran número de herramientas en R para efectura representaciones de mapas. Por ejemplo, los mapas de coropletas pueden generarse tanto en versión estática (Figura 5.1) como interactiva (Figura 5.2), utilizando la biblioteca JavaScript Leaflet.\nEl paquete {leaflet}📦 (Cheng et al., 2021) es un interfaz a esta librería que nos permite aprovechar todas las capacidades de R para realizar estos mapas. Los mapas se generan en formato HTML que puede ser publicado en archivos autocontenidos que se abren en el navegador a través de RMarkdown, en servidores web convencionales o aplicaciones Shiny. Al generar documentos estáticos, como Word o PDF, en el documento se mostrará una imagen estática del mapa por defecto.\nEn este capítulo también se incluyen contenidos y ejemplos desarrollados por nuestro compañero del DSLAB Emilio López Cano.\nPara ejecutar todos los ejemplos de este documento necesitas los siguientes paquetes R.\n# Paquetes de funcionalidades\nlibrary(tidyverse)\nlibrary(kableExtra)\nlibrary(htmltools)\n\n# Paquetes de mapas\nlibrary(leaflet)\nlibrary(maps)\nlibrary(sp)\nlibrary(sf)\n# library(simplevis) not in CRAN anymore\nlibrary(mapSpain)\nlibrary(terra)\nlibrary(raster)\nlibrary(mapview)",
    "crumbs": [
      "Visualización avanzada",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Mapas interactivos</span>"
    ]
  },
  {
    "objectID": "05-mapas-interactivos.html#representación-de-datos-puntuales",
    "href": "05-mapas-interactivos.html#representación-de-datos-puntuales",
    "title": "5  Mapas interactivos",
    "section": "5.1 Representación de datos puntuales",
    "text": "5.1 Representación de datos puntuales\n\n5.1.1 Datos de ejemplo\nEn este punto vamos a cargar los datos de ejemplo que vamos a utilizar para representar en el mapa. No siempre los datos están tan bien preparados como en los ejemplos “bonitos” de los paquetes. En este caso hemos descargado un conjunto de datos abiertos del Ayuntamiento de Madrid sobre las estaciones de medición de contaminación.\n\nestaciones &lt;- read_delim(\"https://lcano.com/data/geo/informacion_estaciones_red_calidad_aire.csv\",\n                         delim = \";\", \n                         escape_double = FALSE, \n                         locale = locale(decimal_mark = \".\",\n                                         grouping_mark = \",\", \n                                         encoding = \"ISO-8859-1\"),\n                         trim_ws = TRUE)\nmagnitudes &lt;- read.csv2(\"https://lcano.com/data/geo/magnitudes.csv\")\n\ndatosori &lt;- read_delim(\"https://lcano.com/data/geo/datos202110.csv\", \n                       delim = \";\", \n                       escape_double = FALSE, \n                       locale = locale(decimal_mark = \",\", \n                                       grouping_mark = \".\", \n                                       encoding = \"ISO-8859-1\"), \n                       trim_ws = TRUE)\n\ndatos &lt;- datosori |&gt; \n  inner_join(magnitudes |&gt; dplyr::select(id, Abreviatura),\n             by = c(\"MAGNITUD\" = \"id\")) |&gt; \n  dplyr::select(ESTACION, MAGNITUD = Abreviatura, ANO, MES, starts_with(\"D\")) |&gt; \n  pivot_longer(cols = starts_with(\"D\"),\n               names_to = \"DIA\",\n               values_to = \"Valor\") |&gt; \n  mutate(DIA = str_sub(DIA, 2),\n         Valor = as.numeric(Valor)) |&gt; \n  pivot_wider(names_from = \"MAGNITUD\",\n              values_from = \"Valor\") |&gt; \n  inner_join(estaciones |&gt; dplyr::select(CODIGO_CORTO, LONGITUD, LATITUD),\n             by = c(\"ESTACION\" = \"CODIGO_CORTO\"))\n\nAhora tenemos un data.frame con los datos de las estaciones, incluidas las coordenadas, y otro con los datos de la contaminación, que además hemos unido.\n\nestaciones |&gt; dplyr::select(CODIGO_CORTO, ESTACION, LONGITUD, LATITUD) |&gt;  kbl(format = \"markdown\")\n\n\n\n\nCODIGO_CORTO\nESTACION\nLONGITUD\nLATITUD\n\n\n\n\n4\nPza. de España\n-3.712257\n40.42388\n\n\n8\nEscuelas Aguirre\n-3.682316\n40.42155\n\n\n11\nAvda. Ramón y Cajal\n-3.677349\n40.45147\n\n\n16\nArturo Soria\n-3.639242\n40.44005\n\n\n17\nVillaverde\n-3.713317\n40.34715\n\n\n18\nFarolillo\n-3.731836\n40.39478\n\n\n24\nCasa de Campo\n-3.747345\n40.41936\n\n\n27\nBarajas Pueblo\n-3.580026\n40.47692\n\n\n35\nPza. del Carmen\n-3.703166\n40.41921\n\n\n36\nMoratalaz\n-3.645310\n40.40795\n\n\n38\nCuatro Caminos\n-3.707130\n40.44554\n\n\n39\nBarrio del Pilar\n-3.711536\n40.47823\n\n\n40\nVallecas\n-3.651529\n40.38815\n\n\n47\nMendez Alvaro\n-3.686814\n40.39810\n\n\n48\nCastellana\n-3.690373\n40.43989\n\n\n49\nParque del Retiro\n-3.682500\n40.41444\n\n\n50\nPlaza Castilla\n-3.688745\n40.46558\n\n\n54\nEnsanche de Vallecas\n-3.612139\n40.37301\n\n\n55\nUrb. Embajada\n-3.580565\n40.46236\n\n\n56\nPza. Elíptica\n-3.718768\n40.38503\n\n\n57\nSanchinarro\n-3.660517\n40.49420\n\n\n58\nEl Pardo\n-3.774610\n40.51807\n\n\n59\nJuan Carlos I\n-3.616341\n40.46073\n\n\n60\nTres Olivos\n-3.689731\n40.50055\n\n\n\n\n\n\n\n5.1.2 Marcadores\nUtilizamos marcadores para señalar puntos en el mapa. Las ubicaciones de los marcadores se expresan en coordenadas de latitud y longitud, y pueden aparecer como iconos o como círculos.\n\n5.1.2.1 Fuentes de datos\nLos datos de puntos para los marcadores pueden proceder de diversas fuentes:\n\nObjetos SpatialPoints o SpatialPointsDataFrame (del paquete {sp})\nObjetos POINT, sfc_POINT y sf (del paquete {sf}); sólo se considerarán las dimensiones X e Y\nMatrices numéricas de dos columnas (la primera columna es la longitud y la segunda la latitud)\ndata.frame con columnas de latitud y longitud. Puede indicar explícitamente a la función de marcadores qué columnas contienen los datos de coordenadas (por ejemplo, addMarkers(lng = ~Longitud, lat = ~Latitud)), o dejar que la función busque las columnas denominadas lat/latitud y lon/lng/longitud (sin distinguir mayúsculas y minúsculas).\nSimplemente proporcione vectores numéricos como argumentos lng y lat\n\nTenga en cuenta que los objetos MULTIPOINT de sf no son compatibles en este momento.\n\n\n5.1.2.2 Marcadores de icono\nLos iconos se añaden mediante las funciones addMarkers o addAwesomeMarkers. Su apariencia por defecto es la de un marcador de posición. Como en la mayoría de las funciones de capa, el argumento popup puede utilizarse para añadir un mensaje que se mostrará al hacer clic, y la opción label puede utilizarse para mostrar una etiqueta de texto, ya sea al pasar por encima o de forma estática.\n\nestaciones |&gt; \n  leaflet()  |&gt; \n  addTiles() |&gt; \n  addMarkers(~LONGITUD, ~LATITUD, \n             popup = ~as.character(ESTACION),\n             label = ~as.character(CODIGO_CORTO))\n\n\n\n\n\n\n\n5.1.2.3 Personalización de los iconos de los marcadores\nSe pueden proporcionar marcadores personalizados de varias maneras, dependiendo del escenario. Para cada una de estas formas, el icono puede proporcionarse como una URL o como una ruta de archivo.\nPara el caso simple de aplicar un único icono a un conjunto de marcadores, utiliza makeIcon().\n\nmyIcon &lt;- makeIcon(\n  iconUrl = \"https://lcano.com/c/visr/img/emilio.png\",\n  iconWidth = 20, iconHeight = 20,\n  iconAnchorX = 20, iconAnchorY = 20,\n  shadowUrl = \"https://lcano.com/c/visr/img/emilio.png\",\n  shadowWidth = 20, shadowHeight = 20,\n  shadowAnchorX = 4, shadowAnchorY = 4\n)\n\nleaflet(data = estaciones) |&gt; addTiles() |&gt;\n  addMarkers(~LONGITUD, ~LATITUD, icon = myIcon)\n\n\n\n\n\nSi tienes varios iconos para aplicar que varían sólo por un par de parámetros (es decir, comparten el mismo tamaño y puntos de anclaje pero tienen diferentes URLs), utiliza la función icons(). icons() se comporta de forma similar a data.frame(), en el sentido de que cualquier argumento que sea más corto que el número de marcadores se reciclará para que quepa.\n\nourIcons &lt;- icons(\n  iconUrl = ifelse(estaciones$ALTITUD &lt; 650,\n                   \"https://lcano.com/c/visr/img/emilio.png\",\n                   \"https://lcano.com/c/visr/img/felipe.jpeg\"\n  ),\n  iconWidth = 20, iconHeight = 20,\n  iconAnchorX = 20, iconAnchorY = 20,\n  shadowUrl = \"https://lcano.com/c/visr/img/emilio.png\",\n  shadowWidth = 20, shadowHeight = 20,\n  shadowAnchorX = 4, shadowAnchorY = 4\n)\n\nleaflet(data = estaciones) |&gt; addTiles() |&gt;\n  addMarkers(~LONGITUD, ~LATITUD, icon = ourIcons)\n\n\n\n\n\nPor último, si tienes un conjunto de iconos que varían en varios parámetros, puede ser más conveniente utilizar la función iconList(). Te permite crear una lista de iconos (con o sin nombre) de makeIcon(), y seleccionar de esa lista por posición o nombre.\n\n\n5.1.2.4 Iconos Awesome\nLeaflet soporta aún más marcadores personalizables utilizando el plugin de leaflet awesome markers.\nLa función addAwesomeMarkers() es similar a la función addMarkers() pero además permite especificar colores personalizados para los marcadores así como iconos de las bibliotecas de iconos Font Awesome, Bootstrap Glyphicons e Ion.\nDe forma similar a las funciones makeIcon, icons e iconList descritas anteriormente, tienes las funciones makeAwesomeIcon, awesomeIcons y awesomeIconList, que te permiten añadir iconos awesome\n\n# first 20 quakes\n\ngetColor &lt;- function(estaciones) {\n  sapply(estaciones$ALTITUD, function(al) {\n    if(al &lt;= 625) {\n      \"green\"\n    } else if(al &lt;= 700) {\n      \"orange\"\n    } else {\n      \"red\"\n    } })\n}\n\nicons &lt;- awesomeIcons(\n  icon = 'ios-close',\n  iconColor = 'black',\n  library = 'ion',\n  markerColor = getColor(estaciones)\n)\n\nleaflet(estaciones) |&gt; addTiles() |&gt;\n  addAwesomeMarkers(~LONGITUD, ~LATITUD, icon=icons, label=~as.character(ALTITUD))\n\n\n\n\n\nEl argumento library debe ser uno de los siguientes: ‘ion’, ‘fa’ o ‘glyphicon’. El argumento icon debe ser el nombre de cualquier icono válido soportado por la biblioteca respectiva (sin el prefijo del nombre de la biblioteca).\n\n\n5.1.2.5 Grupos de marcadores\nCuando hay un gran número de marcadores en un mapa, puede agruparlos utilizando el complemento Leaflet.markercluster. Para activar este complemento, puedes proporcionar una lista de opciones al argumento clusterOptions, por ejemplo\n\nleaflet(estaciones) |&gt; addTiles() |&gt; addMarkers(~LONGITUD, ~LATITUD,\n                                                  clusterOptions = markerClusterOptions()\n)\n\n\n\n\n\nUsando el argumento freezeAtZoom de la función markerClusterOptions() puede establecerse que el cluster se congele a un nivel de zoom específico. Por ejemplo, markerClusterOptions(freezeAtZoom = 5) congelará el cluster en el nivel de zoom 5, independientemente del nivel de zoom real del usuario.\n\n\n5.1.2.6 Marcadores de círculo\nLos marcadores de círculo son muy parecidos a los círculos normales (véase Líneas y formas), excepto que su radio en píxeles en pantalla permanece constante independientemente del nivel de zoom.\nPuede utilizar su apariencia por defecto:\n\nleaflet(estaciones) |&gt; addTiles() |&gt; addCircleMarkers(~LONGITUD, ~LATITUD)\n\n\n\n\n\nO personalizar elementos:\n\npal &lt;- colorFactor(c(\"navy\", \"red\"), domain = c(\"ship\", \"pirate\"))\nleaflet(estaciones) |&gt; \n  addTiles() |&gt; \n  addCircleMarkers(~LONGITUD, ~LATITUD,\n                   radius = ~ifelse(COD_TIPO == \"UT\", 6, 10),\n                   color = ~pal(COD_TIPO),\n                   stroke = FALSE, fillOpacity = 0.5)\n\nWarning in pal(COD_TIPO): Some values were outside the color scale and will be\ntreated as NA\nWarning in pal(COD_TIPO): Some values were outside the color scale and will be\ntreated as NA\n\n\n\n\n\n\n\n\n\n5.1.3 Popus y etiquetas\n\n5.1.3.1 Popups (ventanas emergentes)\nLos popups son pequeñas cajas que contienen HTML arbitrario, que apuntan a un punto específico del mapa.\nUtilice la función addPopups() para añadir un popup independiente al mapa.\n\ncontent &lt;- paste(sep = \"&lt;br/&gt;\",\n  \"&lt;b&gt;&lt;a href='http://www.datasciencelab.es'&gt;DSLAB&lt;/a&gt;&lt;/b&gt;\",\n  \"Data Science Laboratory\",\n  \"Móstoles, Madrid\"\n)\n\nleaflet() |&gt; addTiles() |&gt;\n  addPopups(-3.87841, 40.33608, content,\n    options = popupOptions(closeButton = FALSE)\n  )\n\n\n\n\n\nUn uso común de las ventanas emergentes es hacerlas aparecer cuando se hace clic en los marcadores o en las formas. Las funciones de marcadores y formas en el paquete de Leaflet toman un argumento de ventana emergente, donde se puede pasar HTML para adjuntar fácilmente una ventana emergente simple.\n\nestaciones |&gt; \n  leaflet()  |&gt; \n  addTiles() |&gt; \n  addMarkers(~LONGITUD, ~LATITUD, \n             popup = ~as.character(ESTACION))\n\n\n\n\n\nEn el ejemplo anterior, se utilizó htmltools::htmlEscape para sanear cualquier carácter del nombre que pudiera ser interpretado como HTML. Aunque no era necesario para este ejemplo (ya que los nombres de los restaurantes no contenían marcas HTML), hacerlo es importante en cualquier situación en la que los datos puedan provenir de un archivo o base de datos, o del usuario.\nAdemás de los marcadores, también se pueden añadir ventanas emergentes en formas como líneas, círculos y otros polígonos.\n\n\n5.1.3.2 Etiquetas\nUna etiqueta es un contenido textual o HTML que puede adjuntarse a los marcadores y formas para que se muestren siempre o al pasar el ratón por encima. A diferencia de las ventanas emergentes, no es necesario hacer clic en un marcador o polígono para que se muestre la etiqueta.\n\nestaciones |&gt; \n  leaflet()  |&gt; \n  addTiles() |&gt; \n  addMarkers(~LONGITUD, ~LATITUD, \n             label = ~htmlEscape(DIRECCION))\n\n\n\n\n\n\n\n5.1.3.3 Personalización de las etiquetas de los marcadores\nPuede personalizar las etiquetas de los marcadores utilizando el argumento labelOptions de la función addMarkers(). El argumento labelOptions puede rellenarse con la función labelOptions(). Si noHide es falso (el valor predeterminado), la etiqueta se muestra sólo cuando se pasa el ratón por encima del marcador; si noHide se establece como verdadero, la etiqueta se muestra siempre.\n\n\n5.1.3.4 Etiquetas sin marcadores\nPuede crear etiquetas sin los marcadores que las acompañan utilizando la función addLabelOnlyMarkers().\n\n\n\n5.1.4 Datos puntuales en formato sf en {leaflet}\nPara completar este apartado, vamos a comprobar cómo los datos en formato sf también se pueden representar fácilmente con leaflet. Si la geometría son puntos, automáticamente toma las coordenadas sin más. El siguiente ejemplo representa las estaciones de tren de Mallorca usando los datos en formato sf del paquete {mapSpain}.\n\nestaciones_tren &lt;- esp_get_railway(spatialtype = \"point\")\nestaciones_tren |&gt; \n  filter(str_sub(id_ine, 1, 2) == \"07\") |&gt;\n  leaflet() |&gt; \n  addTiles() |&gt; \n  addMarkers()",
    "crumbs": [
      "Visualización avanzada",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Mapas interactivos</span>"
    ]
  },
  {
    "objectID": "05-mapas-interactivos.html#líneas-y-formas",
    "href": "05-mapas-interactivos.html#líneas-y-formas",
    "title": "5  Mapas interactivos",
    "section": "5.2 Líneas y formas",
    "text": "5.2 Líneas y formas\nLeaflet facilita la lectura de líneas y formas espaciales de R y las añade a los mapas.\n\n5.2.1 Polígonos y polilíneas\nLos datos de líneas y polígonos pueden provenir de una variedad de fuentes:\n\nSpatialPolygons, SpatialPolygonsDataFrame, Polygons y objetos Polygon (del paquete {sp})\nSpatialLines, SpatialLinesDataFrame, Lines y objetos Line (del paquete {sp})\nObjetos MULTIPOLYGON, POLYGON, MULTILINESTRING y LINESTRING (del paquete {sf})\nobjetos map (de la función map() del paquete {maps}); utilice map(fill = TRUE) para los polígonos, FALSE para las polilíneas\nMatriz numérica de dos columnas; la primera columna es la longitud y la segunda la latitud. Los polígonos están separados por filas de (NA, NA). No es posible representar polígonos múltiples ni polígonos con agujeros utilizando este método; utilice SpatialPolygons en su lugar.\n\nVamos a representar las vías de tren en España que sean Ferrocarriles autonómicos. Al igual que añadíamos datos puntuales, podemos añadir formar lineales con addPolylines()\n\nvias_tren &lt;- esp_get_railway(spatialtype = \"line\")\nvias_tren |&gt; \n  filter(tipo == \"Ferrocarriles autonómicos\") |&gt;\n  leaflet() |&gt; \n  addTiles() |&gt; \n  addPolylines()\n\n\n\n\n\nEn cuanto a los polígonos, tenemos la función addPolygons(). De nuevo, con objetos de clase sf es totalmente automático.\n\nmadridbase &lt;- esp_munic.sf |&gt; \n  filter(ine.prov.name == \"Madrid\") |&gt; \n  leaflet() |&gt; \n  addTiles() \nmadridbase|&gt; \n  addPolygons()\n\nWarning: sf layer has inconsistent datum (+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs).\nNeed '+proj=longlat +datum=WGS84'\n\n\n\n\n\n\nLas opciones por defecto pueden no ser las adecuadas. Vamos a darle algo de formato y a añadir información adicional. Se pueden añadir labels y popups como en los datos puntuales.\n\nmadridbase |&gt; \n  addPolygons(weight = 1, \n              color = \"orange\",\n              fillOpacity = 0.25,\n              highlightOptions = highlightOptions(color = \"black\",\n                                                  weight = 2,\n                                                  bringToFront = TRUE),\n              label = ~name,\n              popup = ~paste0(\"Código municipio: \", cmun)\n              )\n\nWarning: sf layer has inconsistent datum (+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs).\nNeed '+proj=longlat +datum=WGS84'",
    "crumbs": [
      "Visualización avanzada",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Mapas interactivos</span>"
    ]
  },
  {
    "objectID": "05-mapas-interactivos.html#representación-de-datos-de-área",
    "href": "05-mapas-interactivos.html#representación-de-datos-de-área",
    "title": "5  Mapas interactivos",
    "section": "5.3 Representación de datos de área",
    "text": "5.3 Representación de datos de área\n\n5.3.1 Datos de polígonos\nCuando tenemos datos de polígonos, la representación más sencilla de datos de área es coloreando los polígonos de acuerdo al valor de la variable que queremos representar. Vamos a usar los datos geográficos de los municipios de Madrid del paquete {mapSpain} y los vamos a unir a los datos de población del mismo paquete y a los datos del atlas de renta de los hogares1.\n\nrenta &lt;- readRDS(url(\"https://lcano.com/data/geo/MADRID.rds\")) |&gt; \n  filter(nchar(GEO_codigo) == 5)\nmadrid &lt;- esp_munic.sf  |&gt; \n  inner_join(pobmun19 |&gt; \n               filter(provincia == \"Madrid\") |&gt; \n               dplyr::select(cmun, pob19, men, women), \n             by = \"cmun\") |&gt; \n  inner_join(renta, by = c(\"LAU_CODE\" = \"GEO_codigo\")) \n\n\n\n5.3.2 Colores\nLeaflet tiene una serie de funciones color*() para crear funciones de paletas personalizadas de forma que se puedan mapear las variables a los colores. Esencialmente, se llama a la función de color apropiada con 1) los colores que desea utilizar y 2) opcionalmente, el rango de entradas (es decir, el dominio) que se espera. La función de color devuelve una función de paleta a la que se le puede pasar un vector de valores de entrada, y devolverá un vector de colores en formato #RRGGBB(AA). Por ejemplo:\n\npal &lt;- colorNumeric(c(\"red\", \"green\", \"blue\"), 1:10)\npal(c(1, 6, 9))\n\n[1] \"#FF0000\" \"#52E74B\" \"#6854D8\"\n\n\nLas cuatro funciones de color tienen dos argumentos obligatorios, palette y domain.\nEl argumento palette especifica los colores a los que se asignan los datos. Este argumento puede tomar una de varias formas:\n\nEl nombre de una paleta preestablecida del paquete RColorBrewer, por ejemplo “RdYlBu”, “Accent” o “Greens”.\nEl nombre completo de una paleta viridis: “viridis”, “magma”, “inferno” o “plasma”.\nUn vector de caracteres de colores RGB o con nombre, por ejemplo, palette(), c(\"#000000\", \"#0000FF\", \"#FFFFFF\"), topo.colors(10).\nUna función que recibe un único valor entre 0 y 1 y devuelve un color, por ejemplo: colorRamp(c(\"#000000\", \"#FFFFFF\"), interpolate=\"spline\")\nEl argumento domain indica a la función de color el rango de valores de entrada. Aquí se puede pasar NULL para crear una función de paleta que no tenga un rango preestablecido; el rango se inferirá de los datos cada vez que invoque la función de paleta. Si se utiliza una función de paleta varias veces en diferentes datos, es importante proporcionar un valor no NULL para el dominio para que la escala entre los datos y los colores sea consistente.\n\n\n5.3.2.1 Entrada continua, colores continuos: colorNumeric\nEmpecemos por mapear los valores de la población directamente a la paleta “Blues” de Color Brewer 2. Utilizaremos la función colorNumeric() para crear una función de mapeo. La paleta “Blues” sólo contiene nueve colores, pero colorNumeric() interpola estos colores para que obtengamos una salida continua.\n\npal &lt;- colorNumeric(\n  palette = \"Blues\",\n  domain = madrid$pob19)\n\nEl parámetro palette es la lista ordenada de colores a la que se asignarán los colores. En este caso utilizamos una paleta Color Brewer, pero podríamos haber utilizado c(\"white\", \"navy\") o c(\"#FFFFFF\", \"#000080\") para un efecto similar. También puede pasar más de dos colores, para una paleta divergente, por ejemplo. Y para una máxima flexibilidad, puede incluso pasar una función que tome un valor numérico en el intervalo [0,1] y devuelva un color.\nEl segundo parámetro, domain, indica el conjunto de valores de entrada que estamos mapeando a estos colores. Para colorNumeric, se puede proporcionar un mínimo/máximo como en este ejemplo, o un conjunto de números sobre los que colorNumeric() puede llamar a range().\nEl resultado es pal(), una función que puede aceptar vectores numéricos con valores en el rango range(countries$gdp_md_est) y devolver colores en formato “#RRGGBB”.\n\nmadrid |&gt; \n  leaflet() |&gt; \n  addTiles() |&gt; \n  addPolygons(stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,\n    color = ~pal(pob19))\n\nWarning: sf layer has inconsistent datum (+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs).\nNeed '+proj=longlat +datum=WGS84'\n\n\n\n\n\n\nLo mismo podríamos hacer con las otras varibles, o combinación de estas. Por ejemplo, veamos el mapa según la proporción de mujeres. Tenemos que crear una función de paleta distinta.\n\nmadrid &lt;- madrid |&gt; \n  mutate(propm = women/pob19, .before = \"geometry\") |&gt; \n  mutate(npalabras = factor(str_count(name, \" \") + 1), .before = \"geometry\")\npal &lt;- colorNumeric(\n  palette = \"Blues\",\n  domain = madrid$propm)\nmadridbase2 &lt;- madrid |&gt; \n  leaflet() |&gt; \n  addTiles() \nmadridbase2 |&gt; \n  addPolygons(stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,\n    color = ~pal(propm))\n\nWarning: sf layer has inconsistent datum (+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs).\nNeed '+proj=longlat +datum=WGS84'\n\n\n\n\n\n\n\n\n5.3.2.2 Entrada continua, colores discretos (colorBin y colorQuantile)\nLa función colorBin() asigna los datos de entrada numéricos a un número fijo de colores de salida discretizando (dividiendo el dominio de entrada en varias clases según los valores).\nSe pueden especificar los cortes exactos a utilizar, o el número deseado de intervalos. Téngase en cuenta que, en este último caso, si pretty=TRUE (el valor predeterminado) acabará con cortes redondeados, pero no necesariamente con el número de intervalos deseado.\n\nbinpal &lt;- colorBin(\"viridis\", madrid$propm, 6, pretty = FALSE)\nmadridbase2 |&gt; \n  addPolygons(stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,\n    color = ~binpal(propm))\n\nWarning: sf layer has inconsistent datum (+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs).\nNeed '+proj=longlat +datum=WGS84'\n\n\n\n\n\n\ncolorQuantile() asigna datos numéricos de entrada a un número fijo de colores de salida utilizando cuantiles (cortando el dominio de entrada en subconjuntos con igual número de observaciones). Vamos a usar ahora la variable de la renta.\n\nqpal &lt;- colorQuantile(\"magma\", madrid$Renta, n = 4)\nmadridbase2 |&gt; \n  addPolygons(stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,\n    color = ~qpal(Renta))\n\nWarning: sf layer has inconsistent datum (+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs).\nNeed '+proj=longlat +datum=WGS84'\n\n\n\n\n\n\n\n\n5.3.2.3 Colorear datos categóricos\nPara datos categóricos, se utiliza la función colorFactor(). Si la paleta contiene el mismo número de elementos que niveles de factor, el mapeo será 1:1; en caso contrario, la paleta se interpolará para producir el número de colores deseado.\nSe puede especificar el dominio de entrada pasando un factor o vector de caracteres a domain, o proporcionando niveles directamente usando el parámetro levels (en cuyo caso se ignorará el dominio). A modo de ejemplo, vamos a colorear de forma distinta los municipios según el número de palabras que tiene su nombre.\n\nfactpal &lt;- colorFactor(topo.colors(6), madrid$npalabras)\n\nmadridbase2 |&gt; \n  addPolygons(stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,\n    color = ~factpal(npalabras))\n\nWarning: sf layer has inconsistent datum (+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs).\nNeed '+proj=longlat +datum=WGS84'\n\n\n\n\n\n\n\n\n\n5.3.3 Leyendas\nLas mapas realizados en el apartado anterior carecen de sentido si no se conoce lo que significan los colores.\nLa función addLegend() añade una leyenda al mapa. La forma más sencilla de utilizar addLegend() es proporcionar pal (una función de paleta, como la generada a partir de colorNumeric o las otras) y valores, y dejar que calcule los colores y las etiquetas por sí mismo.\nEn la mayoría de los casos simplemente separaremos la función y el argumento que se pasa a addPolygons(color=...), como en este ejemplo:\n\npal &lt;- colorNumeric(\n  palette = \"YlGnBu\",\n  domain = madrid$propm*100\n)\nmadridbase2 |&gt; \n  addPolygons(stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,\n    color = ~pal(propm*100)\n  ) |&gt; \n  addLegend(\"bottomright\", pal = pal, values = ~propm*100,\n    title = \"Proporción de mujeres\",\n    labFormat = labelFormat(suffix = \"%\"),\n    opacity = 1\n  )\n\nWarning: sf layer has inconsistent datum (+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs).\nNeed '+proj=longlat +datum=WGS84'\n\n\n\n\n\n\nLa función addLegend() tiene en cuenta los diferentes tipos de funciones de paleta, y creará una representación por defecto apropiada para cada tipo. Por ejemplo, compara la leyenda creada para la paleta basada en colorNumeric() anterior con la paleta basada en colorQuantile() a continuación. Esta última muestra los rangos de probabilidad, con un tooltip de rango de valores.\n\nqpal &lt;- colorQuantile(\"RdYlBu\", madrid$propm*100, n = 4)\nmadridbase2 %&gt;%\n  addPolygons(stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,\n    color = ~qpal(madrid$propm*100)\n  ) %&gt;%\n  addLegend(pal = qpal, values = ~madrid$propm*100, opacity = 1)\n\nWarning: sf layer has inconsistent datum (+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs).\nNeed '+proj=longlat +datum=WGS84'\n\n\n\n\n\n\nLa función addLegend() tiene otros parámetros que permiten personalizar la leyenda de varias maneras. En lugar de utilizar pal y valores, se pueden pasar explícitamente colores y etiquetas. Se puede cambiar el título y la opacidad del color.\nTambién se puede personalizar convenientemente la apariencia de la etiqueta pasando labFormat=labelFormat(). La función labelFormat() tiene parámetros que personalizan el separador entre rangos, el número de dígitos a renderizar, y el prefijo/sufijo para cada etiqueta. Si las necesidades de formato de etiqueta van más allá de lo que labelFormat() puede proporcionar, también se puede utilizar una función personalizada como argumento de labFormat(); consulta la sección Details en ?addLegend para obtener una descripción.\n\n\n5.3.4 Datos raster\nLos objetos bidimensionales RasterLayer (del paquete {raster}) pueden convertirse en imágenes y añadirse a los mapas de Leaflet mediante la función addRasterImage().\nLa función addRasterImage() trabaja proyectando el objeto RasterLayer a EPSG:3857 y codificando cada celda a un color RGBA, para producir una imagen PNG. Esa imagen se incrusta en el widget del mapa.\nEs importante que el objeto RasterLayer esté etiquetado con un sistema de referencia de coordenadas adecuado. Muchos archivos raster contienen esta información, pero otros no.\nSi tenemos la imagen raster en la clase SpatRaster de {terra}, primero la convertimos a RasterLayer de {raster}.\n\nraster_filepath &lt;- system.file(\"raster/srtm.tif\", \n                               package = \"spDataLarge\")\nimagen &lt;- raster(rast(raster_filepath))\nleaflet() |&gt; \n  addTiles() |&gt; \n  addRasterImage(imagen)\n\n\n\n\n\nComo se inserta una imagen en el mapa, puede que el archivo html se haga muy grande y la carga sea muy lenta. Si la capa raster es muy grande, se puede usar resample() o aggregate() para reducir el número de celdas (y así el tamaño de archivo).\nPara renderizar la RasterLayer como una imagen, cada valor de celda se convierte a un color RGB(A). Se puede especificar la escala de colores utilizando el argumento colors, que acepta una variedad de especificaciones de color:\n\nEl nombre de una paleta de Color Brewer 2. Si no se proporciona ningún argumento de colores, el valor por defecto es “Espectral”.\nUn vector que representa la lista ordenada de colores para asignar a los datos. Se puede utilizar cualquier especificación de color que sea aceptada por grDevices::col2rgb(), incluyendo las formas “#RRGGBB” y “#RRGGBBAA”. Ejemplo: colors = c(\"#E0F3DB\", \"#A8DDB5\", \"#43A2CA\").\nUna función de escala de color, como las detalladas anteriormente. Por ejemplo: colors = colorBin(\"Greens\", domain = NULL, bins = 5, na.color = \"transparent\").\n\n\npal &lt;- colorNumeric(c(\"#0C2C84\", \"#41B6C4\", \"#FFFFCC\"), values(imagen),\n  na.color = \"transparent\")\n\nleaflet() %&gt;% addTiles() %&gt;%\n  addRasterImage(imagen, colors = pal, opacity = 0.8) %&gt;%\n  addLegend(pal = pal, values = values(imagen),\n    title = \"Elevation\")\n\nWarning in colors(.): Some values were outside the color scale and will be\ntreated as NA",
    "crumbs": [
      "Visualización avanzada",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Mapas interactivos</span>"
    ]
  },
  {
    "objectID": "05-mapas-interactivos.html#representación-avanzada-por-capas-con-mapview",
    "href": "05-mapas-interactivos.html#representación-avanzada-por-capas-con-mapview",
    "title": "5  Mapas interactivos",
    "section": "5.4 Representación avanzada por capas con {mapview}",
    "text": "5.4 Representación avanzada por capas con {mapview}\nEl paquete {mapview} proporciona funciones para crear de forma muy rápida y cómoda visualizaciones interactivas de datos espaciales. Su objetivo principal es llenar el vacío de un trazado interactivo rápido para examinar e investigar visualmente ambos aspectos de los datos espaciales, las geometrías y sus atributos. También se puede considerar una API basada en datos para el paquete {leaflet}, ya que renderizará automáticamente los tipos de mapas correctos, dependiendo del tipo de datos (puntos, líneas, polígonos, raster). Además, hace uso de algunas funcionalidades avanzadas de renderizado que permitirán la visualización de datos mucho más grandes de lo que es posible con {leaflet}.\nLa cantidad de opciones es inmensa, se recomienda consultar la documentación para conocer todas las posibilidades. Dos de las opciones más interesantes son:\n\nAutomáticamente crea las capas de las distintas variables mapeadas, y la información adicional al hacer clic en el objeto espacial. Además, las capas se pueden mostrar y ocultar fácilmente, así como cambiar de fondo.\nSe pueden “mezclar” mapas sin más que “sumarlos”. En el siguiente ejemplo se mezclan los datos de la renta con los de las estaciones de medición de contaminación.\n\n\nsfest &lt;- st_as_sf(estaciones, coords = c(\"LONGITUD\", \"LATITUD\"))\nmapview(madrid, zcol = c(\"pob19\", \"propm\", \"Renta\")) +\nmapview(sfest)\n\n\n\n\n\n\n\n\n\nChang, W., Cheng, J., Allaire, J., Sievert, C., Schloerke, B., Xie, Y., Allen, J., McPherson, J., Dipert, A., & Borges, B. (2021). shiny: Web Application Framework for R. https://shiny.rstudio.com/\n\n\nCheng, J., Karambelkar, B., & Xie, Y. (2021). leaflet: Create Interactive Web Maps with the JavaScript Leaflet Library. https://rstudio.github.io/leaflet/\n\n\nPebesma, E. (2021). sf: Simple Features for R. https://CRAN.R-project.org/package=sf\n\n\nVaidyanathan, R., Xie, Y., Allaire, J., Cheng, J., Sievert, C., & Russell, K. (2021). htmlwidgets: HTML Widgets for R. https://github.com/ramnathv/htmlwidgets\n\n\nXie, Y. (2021). knitr: A General-Purpose Package for Dynamic Report Generation in R. https://yihui.org/knitr/",
    "crumbs": [
      "Visualización avanzada",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Mapas interactivos</span>"
    ]
  },
  {
    "objectID": "05-mapas-interactivos.html#footnotes",
    "href": "05-mapas-interactivos.html#footnotes",
    "title": "5  Mapas interactivos",
    "section": "",
    "text": "https://www.ine.es/experimental/atlas/exp_atlas_tab.htm↩︎",
    "crumbs": [
      "Visualización avanzada",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Mapas interactivos</span>"
    ]
  },
  {
    "objectID": "06-dashboards.html",
    "href": "06-dashboards.html",
    "title": "6  Dashboards",
    "section": "",
    "text": "6.1 Introducción\nUn dashboard es una representación gráfica que muestra un resumen de los principales temas y aspectos que influyen en un proyecto o en un negocio. Está orientado a la toma de decisiones para optimizar la estrategia de negocio o el funcionamiento del proyecto. Nos permiten mostrar una gran cantidad de información de forma sencilla y visualmente atractiva. Por lo que, este tipo de documentos resultan muy comunes en el mundo empresarial.\nEl paquete flexdashboard permite crear dashboard de manera que podamos ver varias visualizaciones de datos relacionadas y organizadas en una sola pantalla en formato HTML. El panel se crea utilizando R Markdown y su diseño está basado en filas y columnas ajustables y fáciles de especificar. Los componentes se redimensionan automáticamente para llenar todo el espacio del navegador y también se adaptan para su visualización en dispositivos móviles.\nDentro de un dashboard podemos incluir una gran variedad de elementos, como: visualizaciones interactivas basdas en htmlwidgets, representaciones estándar de R, datos tabulados, cuadros de texto para resaltar información importante, incluso una barra de navegación. Podemos consultar la documentación oficial del paquete para profundizar más en las múltiples opciones que nos ofrece.\nTambién podemos hacer un dashboard dinámico, es decir, que cambie de acuerdo con la interacción del usuario, usando Shiny (https://rmarkdown.rstudio.com/flexdashboard/shiny.html). Por lo tanto, los paquetes Shiny y flexdashboard son perfectamente compatibles. Al combinar estos paquetes, podemos añadir varios inputs reactivos en nuestro dashboard y mostrar resultados diferentes según la interacción del usuario. De este modo, convertimos un documento estático de R Markdown en un documento interactivo. Pero, al igual que ocurre con las aplicaciones Shiny, vamos a necesitar un servidor Shiny para compartirlos. Sin embargo, los documentos estáticos R Markdown son páginas web independientes que pueden abrirse en cualquier servidor web estándar. En la documentación oficial de dashboard, podéis encontrar un epígrafe completo sobre como llevar a cabo esta combinación.",
    "crumbs": [
      "Visualización avanzada",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dashboards</span>"
    ]
  },
  {
    "objectID": "06-dashboards.html#el-paquete-flexdashboard",
    "href": "06-dashboards.html#el-paquete-flexdashboard",
    "title": "6  Dashboards",
    "section": "6.2 El paquete flexdashboard",
    "text": "6.2 El paquete flexdashboard\nEl paquete flexdashboard nos permite realizar dashboard. Para crear un dashboard con R Markdown tenemos que indicar en los metadatos el formato de salida del siguiente modo: output: flexdashboard :: flex_dashboard. Otra alternativa es, a través del menú File, seleccionamos R Markdown y, en la ventana emergente, dentro de Templates podremos encontrar la opción Flex Dashboard como se muestra en la Figura 6.1.\n\n\n\n\n\n\nFigura 6.1: Nueva ventana en R Markdown.\n\n\n\nComo resultado aparecerá una plantilla para crear nuestro dashboard, Figura 6.2.\n\n\n\n\n\n\nFigura 6.2: Plantilla para un dashboard.\n\n\n\nLos dashboard comparten muchas características con los documentos HTML, como son las opciones de configuración de figuras, la apariencia y estilo del documento y ecuaciones matemáticas.\nLa configuración general del diseño de un dashboard se hace con los títulos del siguiente modo:\n\nLos títulos de primer nivel (#) definen una página nueva.\nLos títulos de segundo nivel (##) definen una columna (o una fila). Cuando definimos varias columnas dentro de una página, podemos especificar el ancho exacto de cada una de ellas:Column {data-width=600}. Por defecto, un dashboard será una única columna que ocupará todo el espacio del navegador.\nLos títulos de tercer nivel (###) definen un cuadro, que puede contener uno o más componentes. Estos cuadros se van colocando en vertical dentro de una columna (o fila).\n\nEl texto de los títulos de segundo nivel no se muestran en la salida. Sin embargo, los de primer y tercer nivel si se muestran como títulos. Veamos algunos ejemplos de estructuras de dashboard:\n\nUn ejemplo de estructura de una página con dos cuadros se muestra en la Figura 6.3:\n\n\n\n\n\n\n\nFigura 6.3: Estructura de una columna.\n\n\n\n# Page 1\n\n### Object1\n\n### Object2\n\nEjemplo de estructura general con varias páginas, cada una de ellas con distinto número de columnas:\n\n# Page 1\n\nColumn1 {data-width=600}\n-------------------------------------\n\n### Object1-1\n\n### Object1-2\n\n\nColumn2 {data-width=400}\n-------------------------------------\n\n### Object2-1\n\n\n# Page 2\n\nColumn1 {data-width=600}\n-------------------------------------\n\n### Object2-1\n\n\nColumn2 {data-width=400}\n-------------------------------------\n\n### Object2-1\n\n\nColumn3 {data-width=400}\n-------------------------------------\n\n### Object2-1\n\n\n6.2.1 Componentes\nVeamos los distintos componentes que podemos añadir en un dashboard:\nHTML widgets. Los gráficos basados en htmlwidgets son ideales para usar con flexdashboard porque pueden redimensionarse dinámicamente. Incluir htmlwidgets en un documento de R Markdown es tan sencillo como incluir cualquier otro gráficos de R, no hay más que llamar a la librería correspondiente. Los htmlwidgets que tenemos disponibles son:\n\nLeaflet, una biblioteca para crear mapas dinámicos que admiten zoom-in y zoom-out, e incluir anotaciones como marcadores, polígonos y ventanas emergentes.\ndygraphs, paquete que proporciona numerosas funciones para la creación de gráficos de datos de series temporales e incluye soporte para muchas funciones interactivas.\nPlotly, es la versión interactiva de ggplot2.\nrbokeh, una interfaz para Bokeh que permite crear gráficos basados ​​en web.\nHighcharter, una rica interfaz R para la popular biblioteca de gráficos JavaScript Highcharts.\nvisNetwork, una interfaz para las capacidades de visualización de red de la biblioteca vis.js.\n\n\n\n\n\n\n\nFigura 6.4: Ejemplo de un HTML widget creado con leaflet.\n\n\n\nGráficas de R. Podemos incluir cualquier tipo de gráfico estándar de R en un dashboard.\nSi estamos trabajando con un dashboard dinámico, estos gráficos se dimensionan automáticamente para caber dentro de los contenedores siempre y cuando su código se encuentre dentro de una llamada a renderPlot. Sin embargo, si nuestro dashboard es estático, como estos gráficos son imágenes PNG, puede haber algún problema a la hora de llenar los límites del contenedor en el que se encuentre. En estos casos, una buena práctica de diseño es definir en el knitr los valores de fig.width y fig.height lo más cerca posible de lo que realmente estarán en la página, así el tamaño renderizado de la gráfica se ajustará lo más posible a su contenedor.\n\n\n\n\n\n\nFigura 6.5: Ejemplo de gráficos estándar de R.\n\n\n\nDatos tabulados. Podemos incluir tablas simples y objetos DataTable. Las tablas simples son ideales para cantidades pequeñas de registros. Dentro de un dashboard estático, incluiremos el código knitr :: kable para añadir una tabla simple. Para un dashboard dinámico usaremos la función renderTable dentro de la sección render para asegurarnos de que la visualización se actualice cuando cambien las entradas de las que depende.\nEl paquete DT nos permite mostrar matrices o marcos de datos como tablas HTML interactivas que admiten filtrado, paginación y clasificación. Para poder usar la función datatable de DataTables con flexdashboard, hay que instalar la última versión de DT (v0.2) de CRAN, ya que contiene algunos cambios necesarios para la compatibilidad con flexdashboard. Si estamos trabajando con un conjunto de datos pequeño, puede interesarnos desactivar la opción de paginación: bPaginate = FALSE, ya que en estos casos mediante el desplazamiento conseguimos navegar de forma muy cómoda a través de los datos. Sin embargo, si tenemos un conjunto de datos grande, deberemos habilitar la paginación y especificar la opción pageLength con el número de filas que queramos mostrar en cada página (el valor por defecto son 10 filas).\nTambién es posible incluir un objeto DataTable dentro de un Shiny flexdashboard, solo tendremos que incluir la salida de la tabla de datos en DT::renderDataTable para que se actualice cuando cambién las entradas de las que depende.\n\n\n\n\n\n\nFigura 6.6: Ejemplo de datos tabulados.\n\n\n\nCajas de valores. Las cajas de valores nos permiente visualizar valores simples. Mediante la función valueBox podemos crear estos elementos junto con un título y un icono. El icono se lo pasamos mediante el argumento icon. También es posible cambiar el color de fondo mediante el argumento color. Tenemos varias opciones para el color: primary (valor por defecto), info, success, warning y danger, incluso podemos definir el color con un CSS válido (por ejemplo, “#ffffff”, “rgb (100,100,100)”, etc.).\nSi el valor que queremos mostrar en un valueBox está relacionado con alguna de las páginas de nuestro dashboard, podemos vincularlo, mediante el argumento href, a esa página de manera que, cuando pichemos sobre él, nos lleve a la página deseada.\nEn cuanto a los iconos, podemos usar tres tipos diferentes: Font Awesome, Ionicons o Bootstrap Glyphicons.\nPor supuesto, también podemos incluir un valueBox dentro de un Shiny dashboard incluyendo el valueBox dentro de renderValueBox.\n\n\n\n\n\n\nFigura 6.7: Ejemplo de cajas de valores.\n\n\n\nGauges. Los Gauges son valores que se visualizan en cajas junto con un arco de medida. La función gauge necesita obligatoriamente los argumentos value, min y max. Podemos especificar un símbolo opcional para que se muestre junto al valor, por ejemplo, “%”. Si definimos rangos de valores mediante la función gaugeSectors nuestro sector se pintará de un color u otro en función de su valor. Los rangos de valores son: success, warning y danger.\nAl igual que ocurría con los valueBox, si el valor que representamos en un Gauge está disponible en otra página de nuestro dashboard, podemos enlazarlo.\n\n\n\n\n\n\nFigura 6.8: Ejemplo de indicadores.\n\n\n\nBarra de navegación Por defecto, en la barra de navegación del dashboard se incluye el título, el autor y la fecha del documento. Si el dashboard tiene varias páginas, también se incluyen sus enlaces en el lado izquierdo de la barra de navegación. Además, podemos personalizar enlaces a otros sitios web desde la barra de navegación mediante la opción navbar. Todos los elementos de la barra de navegación deben incluir un título o un icono (o ambos), junto con el href que indique cual es el destino de navegación. El campo de alineación es opcional, puede ser left o right, siendo este último el valor por defecto.\nMediante la opción social podemos incluir enlaces a alguna de las siguientes redes sociales: facebook, twitter, google-plus, linkedin y pinterest.\nPara incluir un enlace al código fuente tenemos la opción source_code. Si indicamos source_code: embed, el código fuente se incrustará dentro del documento. Mientras que si indicamos source_code: direccion_web estaremos inlcuyendo un enlace a una URL donde estará el código fuente, por ejemplo, source_code: \"https://github.com/ChusAlgar/repo\".\n\n\n\n\n\n\nFigura 6.9: Ejemplo de configuración de la barra de navegación.\n\n\n\nAnimaciones de texto. En ocasiones es necesario incluir alguna explicación adicional dentro del dashboard, por ejemplo, mediante una sección cuyo contenido sea el texto de la explicaicón (en lugar de un gráfico). Otra forma de hacerlo es incluir esa explicación en la parte superior, antes de empezar hacer las secciones del dashboard. Esta opción puede resultar interesante para incluir una breve descripción del contenido del dashboard.",
    "crumbs": [
      "Visualización avanzada",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dashboards</span>"
    ]
  },
  {
    "objectID": "06-dashboards.html#ejemplos.",
    "href": "06-dashboards.html#ejemplos.",
    "title": "6  Dashboards",
    "section": "6.3 Ejemplos.",
    "text": "6.3 Ejemplos.\n\n6.3.1 Components\nEn este primer dashboard mostramos como organizar diferentes elementos dentro de un dashboard de varias páginas con diferente layout. El objetivo es mostrar una recopilación de los principales tipo de componentes que se han explicado en la sección anterior.\nEn la Figura Figura 6.10 se muestra la primera página del dashboard. Esta página está organizada en dos columnas, conteniendo cada una de ellas dos objetos. En la primera columna se ha creado un mapa estático con ggplot2 y un mapa interactivo con leaflet. En la segunda columna se han incluido dos gráficos estándar de R, un histograma y un boxplot de una distribución normal.\n\n\n\n\n\n\nFigura 6.10: Primera página del dashboard Components. Se disponen cuatro elementos diferentes organizados en dos columnas.\n\n\n\nEn la Figura Figura 6.11 podemos ver que la segunda página del dashboard está organizada en filas, por lo que hemos tenido que cambiar su orientación explícitamente. En la primera fila hemos incluido una tabla de datos con DateTable, en la segunda fila se puede observar un ejemplo de value boxes y en la última fila tenemos un ejemplo de indicadores.\n\n\n\n\n\n\nFigura 6.11: Segunda página del dashboard Components. Se disponen tres elementos diferentes organizados en tres filas.\n\n\n\nAdemás, en la barra de navegación se ha añadido un enlace al código fuente y otro a la documentación oficial de flexdashboard.\n\n\n6.3.2 Niveles de poluciónen 2016 en todo el mundo.\nEste dashboard muestra los niveles de contaminación del aire por partículas finas (PM2.5) en cada uno de los países del mundo en 2016. Los datos se han obtenido del Banco Mundial utilizando el paquete wbstats y el mapa mundial se obtiene del paquete rnaturalearth.\nEn la Figura Figura 6.12 se presenta la primera página del dashboard en la que se ha incluido la representación de un mapa interactivo con leaflet y la visualización estática del histograma con ggplot2.\n\n\n\n\n\n\nFigura 6.12: My first dashboard contiene un mapa interactivo y un histograma.\n\n\n\nLa Figura Figura 6.13 muestra el dataset que se ha incluido mediante una tabla DT en la segunda página del dashboard.\n\n\n\n\n\n\nFigura 6.13: La segunda página contiene el dataset.\n\n\n\n\n\n6.3.3 BC Liquor Store Prices\nEn este último ejemplo se muestra en un histograma el consumo de diferentes tipos de bebidas en Canadá, Francia e Italia. Al tratarse de un dashboard dinámica, en la Figura Figura 6.14 se pueden ver los distintos elementos con los que puede interactuar el usuario. Según el país, tipo de bebida y rango de precio, se mostrará su correspondiente histograma así como su tabla de valores.\n\n\n\n\n\n\nFigura 6.14: Shiny Dashboard BC Liquiore Store.",
    "crumbs": [
      "Visualización avanzada",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dashboards</span>"
    ]
  },
  {
    "objectID": "07-casos-estudio.html",
    "href": "07-casos-estudio.html",
    "title": "7  Casos de estudio",
    "section": "",
    "text": "7.1 Representación de datos espaciales con ggplot2\nVamos a utilizar el dataset beech, con datos sobre el estado de salud de las hayas cerca de la localidad alemana de Rothenbuch (Spessart), para componer otros ejemplos de construcción de gráficos para visualización de datos paso a paso con ggplot2.\nDataset beech\nDe acuerdo con la información facilitada en (Fahrmeir et al., 2022), este dataset proviene de un proyecto para comprobar las condiciones en que se encuentra el bosque the Rothenbuch (Spessart), realizado por Axel Göttlein (Tech. Univ., Munich) desde 1982. En este caso, las localizaciones de los árboles examinados están mucho más próximas entre sí de lo habitual en los análisis oficiales a gran escala. Se examinaron árboles en 83 ubicaciones diferentes alrededor de la localidad, centrándose en cinco especies: haya, roble, abeto, alerce y pino. El archivo de datos está restringido a la información sobre las hayas. En concreto, cada año la salud de las hayas se categoriza mediante la variable respuesta defoliation (defoliación), medida en 9 niveles diferentes. La interpretación de los posibles valores es que 0% corresponde a un árbol sano y 100% se asigna a un arbol muerto.\nEn primer lugar, exploramos el contenido de cada una de las columnas incluidas dentro de este dataset.\nlibrary(Hmisc)\n\n\nAdjuntando el paquete: 'Hmisc'\n\n\nThe following objects are masked from 'package:base':\n\n    format.pval, units\n\nlibrary(readr)\n\nbeech &lt;- read_table(\"data/beech.raw\",\n  col_types = cols(id = col_integer(), year = col_integer(), age = col_integer(),\n                   canopyd = col_integer(), gradient = col_integer(),\n                   alt = col_integer(), depth = col_integer(), ph = col_double(),\n                   watermoisture = col_factor(levels = c(\"1\", \"2\", \"3\")),\n                   alkali = col_factor(levels = c(\"1\",\"2\", \"3\", \"4\")),\n                   humus = col_factor(levels = c(\"0\", \"1\", \"2\", \"3\", \"4\",\n                                                 \"5\", \"6\", \"7\", \"8\", \"9\")),\n                   type = col_factor(levels = c(\"0\",\"1\")),\n                   fert = col_factor(levels = c(\"0\",\"1\"))\n                   ))\nstr(beech)\n\nspc_tbl_ [1,796 × 16] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ id           : int [1:1796] 5 5 5 5 5 5 5 5 5 5 ...\n $ year         : int [1:1796] 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 ...\n $ defol        : num [1:1796] 0 0 0 0 0 0 0 0 0 0 ...\n $ x            : num [1:1796] 1.5 1.5 1.5 1.5 1.5 1.5 1.5 1.5 1.5 1.5 ...\n $ y            : num [1:1796] 5 5 5 5 5 5 5 5 5 5 ...\n $ age          : int [1:1796] 43 44 45 46 47 48 49 50 51 52 ...\n $ canopyd      : int [1:1796] 100 100 100 100 100 100 100 100 100 100 ...\n $ gradient     : int [1:1796] 2 2 2 2 2 2 2 2 2 2 ...\n $ alt          : int [1:1796] 320 320 320 320 320 320 320 320 320 320 ...\n $ depth        : int [1:1796] 10 10 10 10 10 10 10 10 10 10 ...\n $ ph           : num [1:1796] 4.61 4.34 4.75 3.99 5.3 3.83 4.05 4.06 4.3 4.84 ...\n $ watermoisture: Factor w/ 3 levels \"1\",\"2\",\"3\": 1 1 1 1 1 1 1 1 1 1 ...\n $ alkali       : Factor w/ 4 levels \"1\",\"2\",\"3\",\"4\": 3 3 3 3 3 3 3 3 3 3 ...\n $ humus        : Factor w/ 10 levels \"0\",\"1\",\"2\",\"3\",..: 3 5 2 4 2 1 1 3 1 1 ...\n $ type         : Factor w/ 2 levels \"0\",\"1\": 2 2 2 2 2 2 2 2 2 2 ...\n $ fert         : Factor w/ 2 levels \"0\",\"1\": 2 2 2 2 2 2 2 2 2 2 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   id = col_integer(),\n  ..   year = col_integer(),\n  ..   defol = col_double(),\n  ..   x = col_double(),\n  ..   y = col_double(),\n  ..   age = col_integer(),\n  ..   canopyd = col_integer(),\n  ..   gradient = col_integer(),\n  ..   alt = col_integer(),\n  ..   depth = col_integer(),\n  ..   ph = col_double(),\n  ..   watermoisture = col_factor(levels = c(\"1\", \"2\", \"3\"), ordered = FALSE, include_na = FALSE),\n  ..   alkali = col_factor(levels = c(\"1\", \"2\", \"3\", \"4\"), ordered = FALSE, include_na = FALSE),\n  ..   humus = col_factor(levels = c(\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"), ordered = FALSE, include_na = FALSE),\n  ..   type = col_factor(levels = c(\"0\", \"1\"), ordered = FALSE, include_na = FALSE),\n  ..   fert = col_factor(levels = c(\"0\", \"1\"), ordered = FALSE, include_na = FALSE)\n  .. )\n\n# Para un resumen más completo:\n# Hmisc::html(describe(beech))\nA continuación, la Figura 7.1 muestra un ejemplo de visualización de estos datos empleando dos canales (color y tamaño) para cada símbolo en el área de representación, junto con diversas facetas (paneles), una para cada año que muestra la evolución del estudio.\nlibrary(ggplot2)\n\nbeech_years &lt;- beech |&gt;\n               dplyr::filter(year == 1983 | year == 1987 |\n                      year == 1991 | year == 1995 |\n                      year == 1999 | year == 2004)\n\np_beech &lt;- ggplot(data = beech_years,\n                  aes(x = x, y = y,\n                      color = defol, size = age)) +\n           geom_point(alpha = 0.6) +\n           facet_wrap(~year, nrow = 3) +\n           theme(\n            legend.text = element_text(size = 12),\n            legend.title = element_text(size = 14),\n            strip.text = element_text(size = 12),\n            axis.text = element_text(size = 12),\n            axis.title = element_text(size = 14), \n           )\np_beech\n\n\n\n\n\n\n\nFigura 7.1: Visualización utilizando dos canales y facetas.\nSeguidamente, la Figura 7.2 muestra un gráfico similar al de la Figura 7.1, pero añadiendo en esta ocasión un tercer canal (forma del símbolo) conectado a los valores categóricos de una variable adicional (alkali). Podemos observar cómo la elevada multicanalidad de este nuevo gráfico empieza a perjudicar la legibilidad de la representación, siendo ya complicado fusionar toda la información que nos proporciona simultáneamente.\np_beech &lt;- ggplot(data = beech_years,\n                  aes(x = x, y = y,\n                      color = defol, size = age)) +\n           geom_point(aes(shape = alkali), alpha = 0.6) +\n           facet_wrap(~year, nrow = 3) +\n           theme(\n            legend.text = element_text(size = 12),\n            legend.title = element_text(size = 14),\n            strip.text = element_text(size = 12),\n            axis.text = element_text(size = 12),\n            axis.title = element_text(size = 14)\n           )\np_beech\n\n\n\n\n\n\n\nFigura 7.2: Visualización utilizando tres canales y facetas.\nSería muy improbable que pudiésemos agregar canales adicionales a esta representación gráfica, con independencia de que todavía existan más variables disponibles. Como vemos, el límite de tres canales simultáneos y añadiendo facetas supone una frontera muy rígida para la representación gráfica de la información.",
    "crumbs": [
      "Aplicaciones",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Casos de estudio</span>"
    ]
  },
  {
    "objectID": "07-casos-estudio.html#representación-de-datos-espaciales-con-ggplot2",
    "href": "07-casos-estudio.html#representación-de-datos-espaciales-con-ggplot2",
    "title": "7  Casos de estudio",
    "section": "",
    "text": "Datos mal codificados\n\n\n\nEl archivo de datos data/beech.raw incluid en el repositorio de este taller, es una copia del archivo original descargado de la página web oficial del libro. Sin embargo, dicho archivo original contiene 3 valores erróneamente codificados (aparece el valor .) para la columna de la variable ph, concretamente en las filas 1678, 1679 y 1797.\nPara evitar errores de lectura, se han recodificado esos tres valores como 4. para los ejemplos de este taller. No obstante, se notifica esta modificación a los usuarios/as que estuviesen interesados en utilizar este dataset para otros fines (como practicar modelos avanzados de regresión).",
    "crumbs": [
      "Aplicaciones",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Casos de estudio</span>"
    ]
  },
  {
    "objectID": "07-casos-estudio.html#uso-del-paquete-mapspain",
    "href": "07-casos-estudio.html#uso-del-paquete-mapspain",
    "title": "7  Casos de estudio",
    "section": "7.2 Uso del paquete mapSpain",
    "text": "7.2 Uso del paquete mapSpain\nVamos a adaptar algunos ejemplos de la charla sobre el paquete mapSpain efectuada para el Grupo de Usuarios de R de Madrid, en noviembre de 2021.\nComo hemos visto, este paquete facilita mucho la creación de mapas de España a diferentes niveles administrativos, permitiendo además usar imágenes de servicios Web Map Service (WMS) o Web Map Tile Service (WMTS). Los segundos suelen ser más eficientes, ya que generan previamente las imágenes de teselas (tiles) para niveles de escala predefinidos, almacenándolos en caché.\nOtro aspecto muy útil son las funciones que incluye este paquete para normalización de los nombres de comunidades autónomas y provicinas, lo que facilita el proceso de manipulación y transformación de datos (aunque no sean, necesariamente, para usarse en visualizaciones espaciales).\nUtiliza varias fuentes de información, tales como GISCO (Eurostat, mediante el paquete giscoR, el IGN, así como diferentes instancias dentro de la Infraestructura de Datos Espaciales de España (IDEE) que publican servicios de teselas en los formatos WMS/WMTS admitidos por este paquete.\n\nPágina web de documentación: https://ropenspain.github.io/mapSpain/.\n\nLo más habitual es descargar e instalar la versión estable del paquete, disponible en CRAN.\n\ninstall.packages(\"mapSpain\", dependencies = TRUE)\n\n\nlibrary(mapSpain)\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ stringr   1.5.2\n✔ forcats   1.0.1     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter()    masks stats::filter()\n✖ dplyr::lag()       masks stats::lag()\n✖ dplyr::src()       masks Hmisc::src()\n✖ dplyr::summarize() masks Hmisc::summarize()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nPara acelerar la ejecución de código, dado que el paquete se descarga datos desde repositorios externos, es muy recomendable establecer un directorio de descarga específico para el usuario.\n\n# El argumento install = TRUE hace esta configuración persistente\nesp_set_cache_dir(\"~/R/mapslib/mapSpain\", install = TRUE, verbose = TRUE)\n\n\n7.2.1 Primer ejemplo: municipios de Castilla-La Mancha\nEn este primer ejemplo, exploramos cómo utilizar las funciones incluidas en mapSpain para representar los municipios de Castilla-La Mancha en diferentes colores, como muestra la Figura 7.3.\n\nlibrary(mapSpain)\nlibrary(tidyverse)\n\ngalicia &lt;- esp_get_munic_siane(region = \"Castilla-La Mancha\") %&gt;%\n  # Normalizar etiquetas\n  mutate(\n    Provincia = esp_dict_translate(ine.prov.name, \"es\")\n  )\nggplot(galicia) +\n  geom_sf(aes(fill = Provincia),\n    color = \"grey70\"\n  ) +\n  labs(title = \"Provincias de Castilla-La Macha\") +\n  scale_fill_discrete(\n    type =\n      hcl.colors(5, \"Purples\")\n  ) +\n  theme_bw()\n\n\n\n\n\n\n\nFigura 7.3: Representación de los municipios de las cinco provincias de Castilla-La Mancha.\n\n\n\n\n\n\n\n7.2.2 Diccionarios de términos\nCuando representamos mapas, es conveniente contar con una representación unívoca de las etiquetas identificadoras de CCAA y provincias. La función esp_dict_region_code() realiza la conversión entre textos y códigos, soportando varios esquemas de codificación (ISO2, NUTS y dos estándares del INE).\nPor otra parte, la función esp_dict_transalate() permite traducir las etiquetas a cinco idiomas distintos (castellano, inglés, catalán, gallego y vasco). Veamos algunos ejemplos.\n\nprovs &lt;- c(\"Murcia\", \"Sevilla\", \"Madrid\", \"Albacete\", \"Baleares\")\n# Codificación de etiquetas\nesp_dict_region_code(provs, destination = \"nuts\")  # Indicar esquema codif.\n\n[1] \"ES62\"  \"ES618\" \"ES30\"  \"ES421\" \"ES53\" \n\nesp_dict_region_code(provs, destination = \"cpro\") # Estándar INE\n\n[1] \"30\" \"41\" \"28\" \"02\" \"07\"\n\nesp_dict_region_code(provs, destination = \"iso2\")\n\n[1] \"ES-MC\" \"ES-SE\" \"ES-MD\" \"ES-AB\" \"ES-IB\"\n\n# Traducciones\nesp_dict_translate(provs, lang = \"en\")\n\n[1] \"Murcia\"           \"Seville\"          \"Madrid\"           \"Albacete\"        \n[5] \"Balearic Islands\"\n\nesp_dict_translate(provs, lang = \"es\")\n\n[1] \"Murcia\"   \"Sevilla\"  \"Madrid\"   \"Albacete\" \"Baleares\"\n\nesp_dict_translate(provs, lang = \"ga\")\n\n[1] \"Murcia\"         \"Sevilla\"        \"Madrid\"         \"Albacete\"      \n[5] \"Illas Baleares\"\n\n\n\n\n7.2.3 Delimitaciones en mapa político\nCon el paquete mapSpain se pueden obtener directamente los límites políticos a diferentes niveles:\n\nTodo el territorio nacional.\nNUTS (Eurostat): clasificación estadística de Eurostat.\n\n0 (país).\n1,2 (CCAA, regiones básicas, políticas regionales).\n3 (regiones menores, diagnósticos específicos).\n\nCCAA.\nProvincias.\nMunicipios.\n\nEn el caso de CCAA, provincias o municipios existen dos versiones que usan diferentes fuentes de datos. En todos los casos, se puede descargar la información en diferente proyecciones y con varios niveles de resolución.\n\nesp_get_xxxx() (GISCO).\nesp_get_xxxx_siane() (fuente: IGN).\n\n\nesp &lt;- esp_get_country(moveCAN = FALSE) # No desplaza Canarias\nggplot(esp) +\n  geom_sf(fill = \"#f9cd94\") +\n  theme_light()\n\n\n\n\n\n\n\nFigura 7.4: Representación estándar del mapa de españa.\n\n\n\n\n\nSe recomienda usar la opción moveCAN = FALSE siempre que se trabaje con imágenes, mapas interactivos o se vayan a realizar análisis espaciales.\nTambién es habitual añadir líneas adicionales en el mapa. Por ejemplo, la Figura 7.5 muestra un mapa similar al anterior, pero además incluyendo el límite entre las dos provincias de Canarias.\n\nesp_can &lt;- esp_get_country()\ncan_prov &lt;- esp_get_can_provinces()\ncan_box &lt;- esp_get_can_box()\nggplot(esp_can) +\n  geom_sf() +\n  geom_sf(data = can_prov) +\n  geom_sf(data = can_box) +\n  theme_linedraw()\n\n\n\n\n\n\n\nFigura 7.5: Mapa político de España que muestra el límite entre las dos provincias de Canarias.\n\n\n\n\n\n\n\n7.2.4 Códigos NUTS\nLa clasificación NUTS 2024 proporciona el listado de los códigos identificativos de las regiones a distintos niveles. La Figura 7.6 muestra el contenido del archivo para las tres regiones de menor nivel de Baleares. A su vez, la Figura 7.7 muestra el mapa ya representado.\n\n\n\n\n\n\nFigura 7.6: Códigos de nivel NUTS 3 para las regiones de menor tamaño de Islas Baleares. Fuente: https://ec.europa.eu/eurostat/web/nuts.\n\n\n\n\nnuts3_baleares &lt;- c(\"ES531\", \"ES532\", \"ES533\")\nnuts3_sf &lt;- esp_get_nuts(region = nuts3_baleares)\nggplot(nuts3_sf) +\n  geom_sf(aes(fill = NAME_LATN)) +\n  labs(fill = \"Baleares: NUTS3\") +\n  scale_fill_viridis_d() +\n  theme_minimal()\n\n\n\n\n\n\n\nFigura 7.7: Mapa de regiones de nivel NUTS 3 de las Islas Baleares.\n\n\n\n\n\n\n\n7.2.5 Límites políticos: Comunidades Autónomas\n\nccaa &lt;- esp_get_ccaa(ccaa = c(\n  \"Catalunya\",\n  \"Comunidad Valenciana\",\n  \"Aragón\",\n  \"Baleares\"\n))\nccaa &lt;- ccaa %&gt;% mutate(\n  ccaa_cat = esp_dict_translate(ccaa$ine.ccaa.name, \"ca\")\n)\nggplot(ccaa) +\n  geom_sf(aes(fill = ccaa_cat)) +\n  labs(fill = \"Comunitats autònomes\") +\n  theme_minimal() +\n  scale_fill_discrete(type = hcl.colors(4, \"Plasma\"))\n\n\n\n\n\n\n\nFigura 7.8: Mapa de varias CCAA en la zona este de España.\n\n\n\n\n\nCon el servicio *_siane (IGN), si se pasa entre los valores una entidad de orden superior (por ejemplo, una CCAA cuando el resto son provincias), entonces se obtienen todas las entidades del mismo nivel que el resto de la lista dentro de la entidad de orden superior. En el siguiente ejemplo, Castilla-La Mancha es una CCAA y el resto son provincias.\n\nprovs &lt;- esp_get_prov_siane(c(\n  \"Castilla-La Mancha\", \"Jaén\",\n  \"Murcia\", \"Alicante\", \"Valencia\"\n))\nggplot(provs) +\n  geom_sf(aes(fill = prov.shortname.es),\n    alpha = 0.9\n  ) +\n  scale_fill_discrete(type = hcl.colors(12, \"Cividis\")) +\n  theme_minimal() +\n  labs(fill = \"Provincias\")\n\n\n\n\n\n\n\nFigura 7.9: Varias provincias españoas, incluyendo todas las de Andalucía.\n\n\n\n\n\n\n\n7.2.6 Límities políticos: municipios\n\nmunic &lt;- esp_get_munic(region = \"Albacete\") %&gt;%\n  # Datos de ejemplo: Población INE\n  left_join(mapSpain::pobmun19, by = c(\"cpro\", \"cmun\"))\nggplot(munic) +\n  geom_sf(aes(fill = pob19), alpha = 0.9, color = NA) +\n  scale_fill_gradientn(\n    colors = hcl.colors(100, \"Inferno\"),\n    n.breaks = 10,\n    labels = scales::label_comma(),\n    guide = guide_legend()\n  ) +\n  labs(\n    fill = \"Habitantes\",\n    title = \"Población en Albacete\",\n    subtitle = \"Datos INE (2019)\"\n  ) +\n  theme_void() +\n  theme(\n    plot.background = element_rect(\"grey80\"),\n    text = element_text(face = \"bold\"),\n    plot.title = element_text(hjust = .5),\n    plot.subtitle = element_text(hjust = .5)\n  )\n\n\n\n\n\n\n\nFigura 7.10: Representación de la población en municipios de la provincia de Albacete.\n\n\n\n\n\nEn el apartado 7.3 del libro sobre visualización de datos de K. Healy (Healy, 2019) se pueden encontrar una representación esquemática más legible de las regiones de un país, llamada statebins, asociada a una variable cuantitativa. Esta representación esquemática es más apropiada cuando el foco de interés es comparar y mostrar resultados cuantitativos entre diferentes regiones sin que importe tanto realizar una representación gráfica fidedigna. La Figura 7.11 y Figura 7.12 muestran dos ejemplos con este paquete para el mapa de España, usando hexágonos y cuadrados, respectivamente.\n\nhex &lt;- esp_get_hex_ccaa()\nggplot(hex) +\n  geom_sf() +\n  geom_sf_text(aes(label = iso2.ccaa.code)) +\n  theme_void()\n\nWarning in st_point_on_surface.sfc(sf::st_zm(x)): st_point_on_surface may not\ngive correct results for longitude/latitude data\n\n\n\n\n\n\n\n\nFigura 7.11: Representación con statebins hexagonales del mapa de España.\n\n\n\n\n\n\ncuad &lt;- esp_get_grid_prov()\nggplot(cuad) +\n  geom_sf() +\n  geom_sf_text(aes(label = iso2.prov.code)) +\n  theme_void()\n\nWarning in st_point_on_surface.sfc(sf::st_zm(x)): st_point_on_surface may not\ngive correct results for longitude/latitude data\n\n\n\n\n\n\n\n\nFigura 7.12: Representación con statebins cuadrados del mapa de España.\n\n\n\n\n\n\n\n7.2.7 Mapas dinámicos con Leaflet\nLos proveedores de diferentes organismos públicos se han conseugido del plug-in para Leaflet leaflet-providerESP.\n\nstations &lt;- esp_get_railway(spatialtype = \"point\", epsg = 4326)\nlibrary(leaflet)\nleaflet(stations, elementId  = \"railways\") %&gt;%\n  addProviderEspTiles(\"IGNBase.Gris\", group = \"Base\") %&gt;%\n  addProviderEspTiles(\"MTN\", group = \"MTN\") %&gt;%\n  addProviderEspTiles(\"RedTransporte.Ferroviario\",\n   group = \"Lineas Ferroviarias\") %&gt;%\n  addMarkers(group = \"Estaciones\",\n    popup = sprintf(\n    \"&lt;strong&gt;%s&lt;/strong&gt;\",\n    stations$rotulo) %&gt;%\n      lapply(htmltools::HTML)\n    ) %&gt;%\n  addLayersControl(\n    baseGroups = c(\"Base\", \"MTN\"),\n    overlayGroups = c(\"Lineas Ferroviarias\", \"Estaciones\"),\n    options = layersControlOptions(collapsed = FALSE)\n  )\n\n\n\n\n\n\n\nFigura 7.13: Mapa dinámico de ubicaciones de estaciones de tren en España.\n\n\n\n\n\n\n7.2.8 Mapas geográficos\n\nhypsobath &lt;- esp_get_hypsobath()\n\n# Error on the data provided - There is an empty shape\n# Remove:\n\nhypsobath &lt;- hypsobath[!sf::st_is_empty(hypsobath), ]\n\n# Tints from Wikipedia\n# https://en.wikipedia.org/wiki/Wikipedia:WikiProject_Maps/Conventions/\n# Topographic_maps\n\nbath_tints &lt;- colorRampPalette(\n  rev(\n    c(\n      \"#D8F2FE\", \"#C6ECFF\", \"#B9E3FF\",\n      \"#ACDBFB\", \"#A1D2F7\", \"#96C9F0\",\n      \"#8DC1EA\", \"#84B9E3\", \"#79B2DE\",\n      \"#71ABD8\"\n    )\n  )\n)\n\nhyps_tints &lt;- colorRampPalette(\n  rev(\n    c(\n      \"#F5F4F2\", \"#E0DED8\", \"#CAC3B8\", \"#BAAE9A\",\n      \"#AC9A7C\", \"#AA8753\", \"#B9985A\", \"#C3A76B\",\n      \"#CAB982\", \"#D3CA9D\", \"#DED6A3\", \"#E8E1B6\",\n      \"#EFEBC0\", \"#E1E4B5\", \"#D1D7AB\", \"#BDCC96\",\n      \"#A8C68F\", \"#94BF8B\", \"#ACD0A5\"\n    )\n  )\n)\n\nlevels &lt;- sort(unique(hypsobath$val_inf))\n\n# Create palette\nbr_bath &lt;- length(levels[levels &lt; 0])\nbr_terrain &lt;- length(levels) - br_bath\n\npal &lt;- c(bath_tints((br_bath)), hyps_tints((br_terrain)))\n\nggplot(hypsobath) +\n  geom_sf(aes(fill = as.factor(val_inf)),\n    color = NA\n  ) +\n  coord_sf(\n    xlim = c(-9.5, 4.4),\n    ylim = c(35.8, 44)\n  ) +\n  scale_fill_manual(values = pal) +\n  guides(fill = guide_legend(\n    title = \"Elevation\",\n    reverse = TRUE,\n    keyheight = .8\n  ))\n\n\n\n\n\n\n\nFigura 7.14: Mapa orográfico (altitudes) de España, sin incluir Canarias.\n\n\n\n\n\n\nhydroland &lt;- esp_get_hydrobasin(domain = \"land\")\nhydrolandsea &lt;- esp_get_hydrobasin(domain = \"landsea\")\n\nggplot(hydroland) +\n  geom_sf(data = hydrolandsea, fill = \"skyblue4\", alpha = .4) +\n  geom_sf(fill = \"skyblue\", alpha = .5) +\n  geom_sf_text(aes(label = rotulo),\n    size = 3, check_overlap = TRUE,\n    fontface = \"bold\",\n    family = \"serif\"\n  ) +\n  coord_sf(\n    xlim = c(-9.5, 4.5),\n    ylim = c(35, 44)\n  ) +\n  theme_void()\n\nWarning in st_point_on_surface.sfc(sf::st_zm(x)): st_point_on_surface may not\ngive correct results for longitude/latitude data\n\n\n\n\n\n\n\n\nFigura 7.15: Mapa de las cuencas hidrográficas en territorio español.",
    "crumbs": [
      "Aplicaciones",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Casos de estudio</span>"
    ]
  },
  {
    "objectID": "07-casos-estudio.html#ejemplos-para-el-paquete-terra-gráficos-raster",
    "href": "07-casos-estudio.html#ejemplos-para-el-paquete-terra-gráficos-raster",
    "title": "7  Casos de estudio",
    "section": "7.3 Ejemplos para el paquete terra (gráficos raster)",
    "text": "7.3 Ejemplos para el paquete terra (gráficos raster)\nEl paquete terra nos permite representar datos ráster (o de trama), que es un formato de datos geoespaciales que representa un área como una cuadrícula de celdas (píxeles). Cada una de estas celdas contiene un valor que representa un atributo o propiedad en una ubicación específica. Este tipo de datos se puede utilizar para mostrar información como imágenes de satélite (por ejemplo, en formatos TIFF, GeoTIFF o JPEG), elevación, temperatura, humedad, precipitación o fotografías aéreas, ya que es compatible con datos tanto continuos como categóricos.\nLa Figura 7.16 muestra un primer ejemplo de representació de datos de elevación en Luxemburgo.\n\nlibrary(terra)\n\nterra 1.8.70\n\n\n\nAdjuntando el paquete: 'terra'\n\n\nThe following object is masked from 'package:tidyr':\n\n    extract\n\n\nThe following objects are masked from 'package:Hmisc':\n\n    describe, mask, zoom\n\nraster_path &lt;- system.file(\"ex/elev.tif\", package = \"terra\")\nr &lt;- rast(raster_path)\nplot(r)\n\n\n\n\n\n\n\nFigura 7.16: Mapa de trama (ráster) que representa datos de elevación en Luxemburgo. Fuente: paquete terra.\n\n\n\n\n\nEl siguiente ejemplo esta tomado de (Moraga, 2023) y utiliza el paquete adicional geodata, que incluye numerosas funciones para descargar datos geográficos. La página de descripción del repositorio de GitHub para este paquete muestra una extensa lista de fuentes de datos que se pueden obtener mediante estas funciones. En la Figura 7.17, usamos datos del proyecto WorldClim sobre la temperatura mensual promedio en diferentes zonas de España.\n\nes_temp_monthly &lt;- geodata::worldclim_country(country = \"Spain\", var = \"tavg\",\n                                res = 10, path = \"data/ESP_wc2.1_30s_tavg.tif\")\nplot(es_temp_monthly)\n\n\n\n\n\n\n\nFigura 7.17: Temperaturas promedio mensuales en España (ºC). Fuente: WorldClim, via paquete geodata.\n\n\n\n\n\nDebemos recordar que estos datos están almacenados en una trama o ráster, por lo que es bastante sencillo calcular, por ejemplo, valores promedios de todos los meses para una representación de la temperatura media anual.\n\nes_temp_yearly &lt;- mean(es_temp_monthly)\nplot(r)\n\n\n\n\n\n\n\nFigura 7.18: Temperaturas promedio anuales en España (ºC). Fuente: WorldClim, via paquete geodata.\n\n\n\n\n\n\n7.3.1 Imágenes satelitales\n\nURL: https://rspatial.org/rs/rs.pdf.\n\nTambién se pueden representar imágenes satelitales utilizando el paquete terra. En el siguiente ejemplo, cargamos 11 archivos de las correspondientes bandas de teledetección proporcionadas por Landsat 8, el 14 de junio de 2017 en un area entre Concord y Stockton (CA, EE.UU.). Por ejemplo, estas imágenes nos permiten realizar análisis comunes en ecología, como el cálculo del NDVI (Índice de Vegetación de Diferencia Normalizada).\n\n# En un caso real, aquí se introduce la ruta a tu propio archivo\n# .tif o .jp2 de Sentinel-2, Landsat u otro proyecto que ofrezca imágenes satelitales \n\n# Cargamos la imagen como un objeto SpatRaster\nsat_all_bands &lt;- paste0('data/rs/LC08_044034_20170614_B', 1:11, \".tif\")\n\n# Carga de imágenes en varias bandas por separado\n# Blue\nb2 &lt;- rast(sat_all_bands[2])\n# Green\nb3 &lt;- rast(sat_all_bands[3])\n# Red\nb4 &lt;- rast(sat_all_bands[4])\n# Near Infrared (NIR)\nb5 &lt;- rast(sat_all_bands[5])\n\n# Sistema de Coordenadas de Referencia (CRS)\n# crs(b2)\n# Número total de celdas, filas y columnas de la trama\nncell(b2)\n\n[1] 1863765\n\n## [1] 1863765\ndim(b2)\n\n[1] 1245 1497    1\n\n## [1] 1245 1497 1\n# Resolución espacial\nres(b2)\n\n[1] 30 30\n\n## [1] 30 30\n# Número de capas (bandas en argot de teledetección)\nnlyr(b2)\n\n[1] 1\n\n## [1] 1\nb2\n\nclass       : SpatRaster \nsize        : 1245, 1497, 1  (nrow, ncol, nlyr)\nresolution  : 30, 30  (x, y)\nextent      : 594090, 639000, 4190190, 4227540  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / UTM zone 10N (EPSG:32610) \nsource      : LC08_044034_20170614_B2.tif \nname        : LC08_044034_20170614_B2 \nmin value   :               0.0748399 \nmax value   :               0.7177562 \n\n# Comparar la extensión, número de filas y columnas, proyección,\n# resolución y origen de dos imágenes de bandas\ncompareGeom(b2, b3)\n\n[1] TRUE\n\nlandsat &lt;- rast(sat_all_bands)\nlandsat\n\nclass       : SpatRaster \nsize        : 1245, 1497, 11  (nrow, ncol, nlyr)\nresolution  : 30, 30  (x, y)\nextent      : 594090, 639000, 4190190, 4227540  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / UTM zone 10N (EPSG:32610) \nsources     : LC08_044034_20170614_B1.tif  \n              LC08_044034_20170614_B2.tif  \n              LC08_044034_20170614_B3.tif  \n              ... and 8 more sources\nnames       : LC08_~14_B1, LC08_~14_B2, LC08_~14_B3, LC08_~14_B4,  LC08_~14_B5,  LC08_~14_B6, ... \nmin values  :  0.09641791,   0.0748399,  0.04259216,  0.02084067, 0.0008457669, -0.007872183, ... \nmax values  :  0.73462820,   0.7177562,  0.69246972,  0.78617686, 1.0124315023,  1.043204546, ... \n\npar(mfrow = c(2,2))\nplot(b2, main = \"Blue\", col = gray(0:100 / 100))\nplot(b3, main = \"Green\", col = gray(0:100 / 100))\nplot(b4, main = \"Red\", col = gray(0:100 / 100))\nplot(b5, main = \"NIR\", col = gray(0:100 / 100))\npar(mfrow=c(1,1)) # Reseteo plot grid\n\n\n\n\n\n\n\nFigura 7.19: Imágenes satelitales en 4 bandas diferentes para un area entre Concord y Stockton (CA, EE.UU.), tomadas el 14 de junio de 2017.\n\n\n\n\n\nPara obtener imágenes más semejantes a las de una fotografía tenemos que combinar las bandas 4 (rojo), 3 (verde) y 2 (azul), para lo cual usamos la función plotRGB.\n\nlandsatRGB &lt;- c(b4, b3, b2)\nplotRGB(landsatRGB, stretch = \"lin\")\n\n\n\n\n\n\n\nFigura 7.20: Imagen satelital de un area entre Concord y Stockton (CA, EE.UU.) en formato RGB.\n\n\n\n\n\nOtro método de visualización muy popular en teledetección es el conocido como “falso color”, que combina las bandas NIR (5), rojo (4) y verde (3). En este caso, las manchas en tonos rojizos nos indican la ubicación de zonas de vegetación.\n\nlandsatFCC &lt;- c(b5, b4, b3)\nplotRGB(landsatFCC, stretch = \"lin\")\n\n\n\n\n\n\n\nFigura 7.21: Imagen satelital en falso color de un area entre Concord y Stockton (CA, EE.UU.).\n\n\n\n\n\nPor último, podemos calcular el índice NDVI.\n\nvi &lt;- function(img, k, i) {\n  bk &lt;- img[[k]]\n  bi &lt;- img[[i]]\n  vi &lt;- (bk - bi) / (bk + bi)\n  return(vi)\n}\n\nndvi &lt;- vi(landsat, 5, 4)\nplot(ndvi, col=rev(terrain.colors(10)), main = \"NDVI\")\n\n\n\n\n\n\n\nFigura 7.22: Representación de valores del NDVI de un area entre Concord y Stockton (CA, EE.UU.).\n\n\n\n\n\n\nhist(ndvi, main = \"NDVI values\", xlab = \"NDVI\", ylab= \"Frequency\",\ncol = \"wheat\", xlim = c(-0.5, 1), breaks = 30, xaxt = \"n\")\n\nWarning: [hist] a sample of 54% of the cells was used\n\n## Warning: [hist] a sample of54% of the cells was used\naxis(side=1, at = seq(-0.6, 1, 0.2), labels = seq(-0.6, 1, 0.2))\n\n\n\n\n\n\n\nFigura 7.23: Representación del histograma de valores del NDVI contenidos en una imagen de un area entre Concord y Stockton (CA, EE.UU.).",
    "crumbs": [
      "Aplicaciones",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Casos de estudio</span>"
    ]
  },
  {
    "objectID": "07-casos-estudio.html#tutorial-paquete-rsi",
    "href": "07-casos-estudio.html#tutorial-paquete-rsi",
    "title": "7  Casos de estudio",
    "section": "7.4 Tutorial paquete rsi",
    "text": "7.4 Tutorial paquete rsi\n\nURL: https://geocompx.org/post/2024/rsi-bp1/\n\nEl paquete rsi de reciente creación a cargo de Michael Mahoney incluye muchas características que simplifican el proceso de adquisición de datos espaciales de STAC (Spatio Temporal Asset Catalog) y el cálculo de índices espectrales (como el NVDI) basados en esos datos. Los índices se obtienen del proyecto Awesome Spectral Indices, lo que simplifica los procesos de teledetcción en combinación con datos STAC, así como la automaticación del cálculo de índices espectrales para áreas amplias y largos periodos de tiempo.",
    "crumbs": [
      "Aplicaciones",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Casos de estudio</span>"
    ]
  },
  {
    "objectID": "07-casos-estudio.html#caso-de-estudio-en-ecología",
    "href": "07-casos-estudio.html#caso-de-estudio-en-ecología",
    "title": "7  Casos de estudio",
    "section": "7.5 Caso de estudio en ecología",
    "text": "7.5 Caso de estudio en ecología\n\nURL: https://r.geocompx.org/eco.\n\nLa segunda edición en línea del libro Geocomputation with R (Lovelace et al., 2025) incluye un caso de estudio interesante, que analiza la composición y la distribución espacial de las plantas vasculares (en este caso, principalmente plantas con flores) en la ladera sur del monte Mongón, una sierra cercana a Casma, en la costa centro-norte de Perú.\nEn ese ejemplo se puede observar cómo combinar varios de los paquetes que hemos presentado en este taller para efectuar representación de datos espaciales, en un caso de aplicación de ecología.\n\n\n\n\nFahrmeir, L., Kneib, T., Lang, S., & Marx, B. D. (2022). Regression: Models, Methods and Applicatons (2.ª ed.). Springer-Verlag GmbH. https://doi.org/10.1007/978-3-662-63882-8\n\n\nHealy, K. (2019). Data Visualization. A Practical Introduction. Princeton University Press. https://socviz.co/\n\n\nLovelace, R., Nowosad, J., & Muenchow, J. (2025). Geocomputation with R. Chapman; Hall/CRC.\n\n\nMoraga, P. (2023). Spatial Statistics for Data Science: Theory and Practice with R. Chapman & Hall/CRC Press. https://doi.org/10.1201/9781032641522",
    "crumbs": [
      "Aplicaciones",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Casos de estudio</span>"
    ]
  },
  {
    "objectID": "08-add-resources.html",
    "href": "08-add-resources.html",
    "title": "8  Recursos adicionales",
    "section": "",
    "text": "Manual oficial de ggplot2: https://ggplot2-book.org (3ª ed. en progreso).\nGráficos para datos espaciales con R: https://r-charts.com/es/espacial/.\n\nLas dos fuentes principales para aprendizaje sobre procesado y análisis de datos espaciales en R son:\n\nGeocomputation with R (lovelace2025?).\nSpatial Data Science: With Applications in R (Pebesma & Bivand, 2023).\n\nOtras referencias interesantes que explican distintos tipos de modelos de análisis de datos espaciales, incluyendo una gran dosis de representaciones gráficas son:\n\nSpatial Statistics for Data Science: Theory and Practice with R (Moraga, 2023).\nBayesian Inference with INLA (Rubio, 2020).\n\n\n\n\n\nMoraga, P. (2023). Spatial Statistics for Data Science: Theory and Practice with R. Chapman & Hall/CRC Press. https://doi.org/10.1201/9781032641522\n\n\nPebesma, E., & Bivand, R. (2023). Spatial Data Science with Applications in R. Chapman & Hall. https://r-spatial.org/book/\n\n\nRubio, V. G. (2020). Bayesian Inference with INLA. Chapman & Hall/CRC Press. https://doi.org/10.1201/9781315175584",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Recursos adicionales</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referencias",
    "section": "",
    "text": "Chang, W., Cheng, J., Allaire, J., Sievert, C., Schloerke, B., Xie, Y.,\nAllen, J., McPherson, J., Dipert, A., & Borges, B. (2021).\nShiny: Web application framework for r. https://shiny.rstudio.com/\n\n\nCheng, J., Karambelkar, B., & Xie, Y. (2021). Leaflet: Create\ninteractive web maps with the JavaScript leaflet library. https://rstudio.github.io/leaflet/\n\n\nCressie, N. A. C. (1993). Statistics for spatial data. Revised\nedition. Wiley. https://doi.org/10.1002/9781119115151\n\n\nFahrmeir, L., Kneib, T., Lang, S., & Marx, B. D. (2022).\nRegression: Models, Methods and\nApplicatons (2nd ed.). Springer-Verlag GmbH. https://doi.org/10.1007/978-3-662-63882-8\n\n\nHealy, K. (2019). Data visualization. A practical introduction.\nPrinceton University Press. https://socviz.co/\n\n\nIhaka, R., & Gentleman, R. (1996). R: A language for data analysis\nand graphics. Journal of Computational and Graphical\nStatistics, 5(3), 299–314.\n\n\nLovelace, R., Nowosad, J., & Muenchow, J. (2019). Geocomputation\nwith r. Chapman; Hall/CRC.\n\n\nLovelace, R., Nowosad, J., & Muenchow, J. (2025). Geocomputation\nwith r. Chapman; Hall/CRC.\n\n\nMoraga, P. (2023). Spatial statistics for data science: Theory and\npractice with r. Chapman & Hall/CRC Press. https://doi.org/10.1201/9781032641522\n\n\nPebesma, E. (2021). Sf: Simple features for r. https://CRAN.R-project.org/package=sf\n\n\nPebesma, E., & Bivand, R. (2023). Spatial data science with\napplications in r. Chapman & Hall. https://r-spatial.org/book/\n\n\nR Core Team. (2025). R: A language and environment for statistical\ncomputing. R Foundation for Statistical Computing. https://www.R-project.org/\n\n\nRubio, V. G. (2020). Bayesian inference with INLA. Chapman\n& Hall/CRC Press. https://doi.org/10.1201/9781315175584\n\n\nVaidyanathan, R., Xie, Y., Allaire, J., Cheng, J., Sievert, C., &\nRussell, K. (2021). Htmlwidgets: HTML widgets for r. https://github.com/ramnathv/htmlwidgets\n\n\nVenables, W. N., & Ripley, B. D. (2002). Modern applied\nstatistics with s. Springer.\n\n\nXie, Y. (2021). Knitr: A general-purpose package for dynamic report\ngeneration in r. https://yihui.org/knitr/",
    "crumbs": [
      "Referencias"
    ]
  },
  {
    "objectID": "A-command-ref.html",
    "href": "A-command-ref.html",
    "title": "Apéndice A — Referencia de comandos",
    "section": "",
    "text": "A.1 Paquete ggplot2",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Referencia de comandos</span>"
    ]
  },
  {
    "objectID": "A-command-ref.html#paquete-ggplot2",
    "href": "A-command-ref.html#paquete-ggplot2",
    "title": "Apéndice A — Referencia de comandos",
    "section": "",
    "text": "Índice de funciones del paquete ggplot2: https://ggplot2.tidyverse.org/reference/.\nData visualization with ggplot2 cheat sheet: https://rstudio.github.io/cheatsheets/html/data-visualization.html.\nManual oficial de ggplot2: https://ggplot2-book.org (3ª ed. en progreso).",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Referencia de comandos</span>"
    ]
  },
  {
    "objectID": "A-command-ref.html#datos-espaciales",
    "href": "A-command-ref.html#datos-espaciales",
    "title": "Apéndice A — Referencia de comandos",
    "section": "A.2 Datos espaciales",
    "text": "A.2 Datos espaciales\n\nÍndice de funciones del paquete sf: https://r-spatial.github.io/sf/reference/index.html.\nÍndice de funciones del paquete terra: https://rspatial.github.io/terra/reference/index.html.\nSpatial Data Science with Applications in R (paquete sf): https://r-spatial.org/book/.\nGeocomputation with R (paquete terra): https://r.geocompx.org/.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Referencia de comandos</span>"
    ]
  },
  {
    "objectID": "B-packages.html",
    "href": "B-packages.html",
    "title": "Apéndice B — Paquetes R y atribuciones",
    "section": "",
    "text": "B.1 Paquetes R\nPara ejecutar los ejemplos incluidos en este taller, se necesita tener instalado R y una IDE de desarrollo para este lenguaje, como por ejemplo RStudio o Microsoft VS Code.\nAdemás, es necesario instalar los paquete descritos en la Tabla B.1.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Paquetes R y atribuciones</span>"
    ]
  },
  {
    "objectID": "B-packages.html#sec-pkg-requirements",
    "href": "B-packages.html#sec-pkg-requirements",
    "title": "Apéndice B — Paquetes R y atribuciones",
    "section": "",
    "text": "Tabla B.1: Listado de paquetes R utilizados en los ejemplos de este taller.\n\n\n\n\n\n\n\n\n\nPaquete\nDescripción\n\n\n\n\nggplot2\nPaquete principal de visualización de datos en el Tidyverse\n\n\ntidyverse\nMetapaquete que instala las herramientas principales del Tidyverse\n\n\nagridat\nConjunto de datos sobre experimentos deagricultura, incluyendo cultivos de campo, cultivos arbóreos o estudios con animales, entre otros\n\n\nHmisc\nFunciones de utilidad desarrolladas por Frank E. Harrell\n\n\nggthemes\nTemas adicionales para personalizar gráficos con ggplot2\n\n\nsf\nSoporte para manipulación y representación de objetos codificados con el estándar simple features\n\n\nterra\nSoporte para manipulación y representación de objetos de tipo raster\n\n\nmapview\nCreación de gráficos espaciales intereactivos en R\n\n\nmapSpain\nFacilita la creación de mapas a diferentes niveles administrativos de España\n\n\nclimaemet\nAcceso a datos de la AEMET desde R\n\n\nairqualityES\nDatos sobre calidad del aire en España (periodio de 18 años)",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Paquetes R y atribuciones</span>"
    ]
  },
  {
    "objectID": "B-packages.html#atribución-de-imágenes-e-iconos",
    "href": "B-packages.html#atribución-de-imágenes-e-iconos",
    "title": "Apéndice B — Paquetes R y atribuciones",
    "section": "B.2 Atribución de imágenes e iconos",
    "text": "B.2 Atribución de imágenes e iconos\nTodas las imágenes utilizadas de fuentes externas reciben atribución junto a su aparición en los contenidos de este taller.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Paquetes R y atribuciones</span>"
    ]
  }
]