[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Visualización de datos espaciales con R",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "01-introduccion.html",
    "href": "01-introduccion.html",
    "title": "1  Introducción",
    "section": "",
    "text": "1.1 Tipos de datos espaciales\nLos datos espaciales son aquellos que incluyen cualquier tipo de información que determine una ubicación asociada a una muestra. Un buen ejemplo son las coordenadas de latitud y longitud, que se pueden registrar gracias a la proliferación de dispositivos equipados con GPS. Otros ejemplos serían datos recogidos por provincias en un país o muestras recogidas en una explotación agrícola, dividida previamente en cuadrículas a intervalos regulares para tomar datos en cada sección.\nSegún la clasificación ofrecida por Cressie (1993), podemos distinguir tres tipos principales de datos espaciales:\nAdemás de los datos con dependencias espaciales, en la actualidad surgen también muchos estudios que involucran datos espacio-temporales. En este tipo de datos, las variables observadas tienen simultáneamente tanto dependencia espacial como temporal. Un ejemplo sería la concentración de agentes contaminantes en diferentes zonas de una ciudad, medida diariamente a lo largo de un año.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "01-introduccion.html#tipos-de-datos-espaciales",
    "href": "01-introduccion.html#tipos-de-datos-espaciales",
    "title": "1  Introducción",
    "section": "",
    "text": "Datos geoestadísticos (geostatistical data): datos espaciales cuya variación se produce sobre un espacio continuo. La variable de interés (respuesta) puede ser discreta o continua. Algunos ejemplos son:\n\nNiveles de polución en diferentes zonas de una ciudad.\nNiveles de ozono medidos en una determinada zona geográfica.\nPrecipitación registrada en un territorio durante una jornada.\n\nMalla de datos (lattice data): en este caso, la variación se produce sobre un dominio discreto, por lo que los datos solo pueden ocurrir en un conjunto fijo de localizaciones que se pueden enumerar. En la mayoría de casos, se trata de datos agregados sobre áreas o regiones. Ejemplos:\n\nRegiones censales.\nCódigos postales.\nBarrios o distritos.\nCondados, provincias.\n\nPatrones puntuales (point pattern data): La variable de interés es la localización de eventos que se producen en ubicaciones específicas, sobre un espacio discreto o continuo. Un ejemplo sería la posición de los incendios forestales producidos durante un año en una provincia española. El objetivo más común es determinar si las realizaciones del evento de interés siguen algún patrón dentro del área de estudio o son aleatorias. Más concretamente:\n\nSi las ubicaciones de los eventos son completamente aleatorias (las posiciones de los eventos no afectan a las de otros eventos).\nSi las ubicaciones son uniformes o regulares (cada evento está lo más alejado posible de los eventos vecinos).\nSi las ubicaciones están agregadas o forman clusters (los eventos tienden a agruparse en ciertas localizaciones).",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "01-introduccion.html#estadística-para-datos-espaciales",
    "href": "01-introduccion.html#estadística-para-datos-espaciales",
    "title": "1  Introducción",
    "section": "1.2 Estadística para datos espaciales",
    "text": "1.2 Estadística para datos espaciales\nCuando los datos recogidos poseen dependencias estrictas (espaciales, temporales, o espacio-temporales), no podemos utilizar técnicas estadísticas convencionales para analizarlos. En efecto, las herramientas de estadística clásica exigen, como condición indispensable, que exista independencia entre los valores observados. Esta norma claramente no se cumple para datos con dependencias. Por ejemplo, en el caso de datos espaciales es muy común que exista alguna relación entre muestras recogidas en ubicaciones cercanas entre sí.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "01-introduccion.html#r-y-su-ecosistema",
    "href": "01-introduccion.html#r-y-su-ecosistema",
    "title": "1  Introducción",
    "section": "1.3 R y su ecosistema",
    "text": "1.3 R y su ecosistema\nEl análisis estadístico de datos es una tarea fundamental en la transformación digital de las empresas y organizaciones. Siempre ha estado ahí, pero en la actualidad la disponibilidad de datos, la cantidad de los mismos, y la velocidad con la que se requieren resultados, está haciendo necesario el capacitar a los profesionales para el análisis de datos con nuevas herramientas. Nuevas tendencias (muchas veces malinterpretadas) como Big Data, Industria 4.0, Internet of Things (IoT), o Data Science, aumentan el interés por parte de las empresas, los profesionales y los investigadores en estas técnicas.\nEl tratamiento de datos y su análisis requiere el uso de software avanzado. Aunque algunas tareas se puede realizar eficazmente con programas de hoja de cálculo como Excel (por ejemplo, son una buena herramienta para mecanizar y almacenar datos), se debería utilizar software especializado para el análisis de datos. Existen distintos paquetes estadísticos comerciales, como SPSS, Statgraphics, Stata, JMP o Minitab (líder en análisis de datos para metodologías de calidad). En los últimos años se ha abierto camino como alternativa el software estadístico y lenguaje de programación R (R Core Team, 2025). Hay otras alternativas que en su mayoría, o son parciales referidas a un ámbito concreto, o son más lenguajes de programación que software estadístico, como Python. R es software libre, pero su gratuidad solo es una de sus ventajas (free as in free beer, and free as in free speech), como se verá a lo largo del curso. El gran inconveniente es la curva de aprendizaje: no es tan fácil de aprender y usar como un software de ventanas, ya que el uso de R se basa en expresiones que hay que ejecutar desde scripts. No obstante, una vez que se tienen las nociones básicas es fácil ir aplicando nuevos métodos.\nR es un sistema para computación estadística: software de análisis de datos y lenguaje de programación. Ha sido ampliamente utilizado en investigación y docencia, y actualmente también en las empresas y organismos públicos. Es la evolución del trabajo de los laboratorios Bell con el lenguaje S (Venables & Ripley, 2002), llevado al mundo del software libre por Ross Ihaka y Robert Gentleman en los años 90 (Ihaka & Gentleman, 1996). La version R 1.0.0 se publicó el 29 de febrero de 2000.\nEn R tenemos numerosos paquetes para representar información geográfica que nos permiten realizar la lectura y escritura de este tipo de datos, llevar a cabo análisis de patrones de puntos y operaciones geoestadísticas. Básicamente existen dos mecanismos para trabajar con datos espaciales:\n\nVectores. En este modelo, el mundo real se representa mediante puntos, líneas, polígonos y combinaciones de todos ellos. Por lo que la información se define mediante pares o ternas de valores. Es decir, los datos vectoriales describen la forma de un objeto y también pueden incluir variables adicionales. Por ejemplo, un conjunto de datos vectoriales puede ser la frontera de las comunidades autónomas de España y, además, puede contener información como el nombre de la comunidad autónoma y su número de habitantes. Este modelo es muy utilizado en el campo de las ciencias sociales porque la información con la que se trabaja tiende a tener fronteras muy bien definidas.\nRáster. Este modelo organiza el espacio como una matriz de celdas de igual tamaño. En cada celda se guarda la información correspondiente a ella. Es decir, cada celda contiene la información de los objetos que están en ella. Se trabaja por capas, agregando características espaciales a una resolución determinada, por lo que resulta muy útil para representar información continua a lo largo de un área. Este modelo es muy utilizado en la cartografía web, en la fotografía aérea y en los dispositivos de teledetección basados en satélites. Por este motivo, en el ámbito de las ciencias ambientales se usa más la filosofía ráster.\n\n\n\n\n\nCressie, N. A. C. (1993). Statistics for Spatial Data. Revised Edition. Wiley. https://doi.org/10.1002/9781119115151\n\n\nIhaka, R., & Gentleman, R. (1996). R: a language for data analysis and graphics. Journal of computational and graphical statistics, 5(3), 299-314.\n\n\nR Core Team. (2025). R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing. https://www.R-project.org/\n\n\nVenables, W. N., & Ripley, B. D. (2002). Modern applied statistics with S. Springer.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "02-datos-espaciales.html",
    "href": "02-datos-espaciales.html",
    "title": "2  Datos espaciales",
    "section": "",
    "text": "2.1 El paquete {sf}\nEn lo que resta del taller, vamos a utilizar (entre otros) los paquetes que cargamos a continuación. Asegúrate de tenerlos instalados antes de continuar con la ejecución del código. Nótese que el paquete {spDataLarge} hay que instalarlo desde un repositorio específico como se indica en la línea comentada. 1",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datos espaciales</span>"
    ]
  },
  {
    "objectID": "02-datos-espaciales.html#el-paquete-sf",
    "href": "02-datos-espaciales.html#el-paquete-sf",
    "title": "2  Datos espaciales",
    "section": "",
    "text": "2.1.1 Introdución\nEl modelo de datos vectoriales se basa en ubicar puntos dentro de un sistema de referencia de coordenadas (CRS). Es decir, dado un CRS, mediante las coordenadas de un punto podemos representar características independientes (por ejemplo, la ubicación de un colegio). También podemos unir estos puntos para obtener formas geométricas más complejas, como líneas y polígonos.\nEn la mayoría de los casos, las geometrías de puntos están definidas en dos dimensiones (X e Y, o latitud y longitud). Si usamos un sistema de tres dimensiones, la tercera dimensión, Z, típicamente representa la altura sobre el nivel del mar.\nEn R podemos encontrar el paquete {sp} que permite trabajar con datos vectoriales proporcionando la información espacial mediante vértices de polígonos. Mediante la función plot() podemos realizar una representación gráfica estática, aunque un tanto limitada. Haciendo uso de los paquetes {tmap}, {ggplot2} y {ggmap} podemos obtener representaciones estáticas mucho más atracticas. También es posible realizar representaciones dinámicas junto con el paquete {leaflet}.\nSin embargo, {sp} se utliza cada vez menos ya que está siendo reemplazado por el paquete {sf}. Este paquete sigue el estandar simple feature definido por la Open Geospatial Consortium (OGC), una organización sin ánimo de lucro cuya principal función es definir estándares para trabajar con datos espaciales. El paquete {sf} proporciona un sistema de clases para datos vectoriales geográficos. Además, tiene una interfaz de línea de comandos consistente para GEOS y GDAL.\n\n\n2.1.2 Simple features\nEl estándar simple features es un modelo común de almacenamiento y acceso para atributos geográficos, creado principalmente para geometrías 2-D (puntos, polígonos, líneas, etc.). Permite conexión con bases de datos geográficas (e.g. PostGIS) y también con Sistemas de Información Geográfica (GIS, por sus siglas), tales como ArcGIS.\nEn R, el paquete sf da soporte para trabajar con datos representados según el estándar simple features. Los registros de datos espaciales se almacenan en un objeto data.frame o tibble con una columna que contiene la información de geometría a representar. Están soportados los 17 tipos de datos representables con simple features en todas las dimensiones. También tiene interfaces con sistemas externos como GEOS, s2geometry, GDAL o PRØJ para realizar multitud de operaciones sobre distintos tipos de objetos y espacios de coordenadas.\nExiste un listado de operaciones soportadas por sf que resume las capacidades completas de este paquete.\nEn particular la función geom_sf() permite incorporar objetos espaciales geométricos gestionados mediante el paquete sf como una capa más de nuestros gráficos creados con ggplot2. También es totalmente compatible con las funciones del paquete dplyr.\nEn sf contamos con diferentes funciones para representar todos los tipos de geometrías vectoriales: puntos, líneas, polígonos y sus respectivas versiones “múltiples” (que agrupan entidades del mismo tipo en una única entidad). Así mismo, podemos agrupar varias geometrías en un solo objeto. También es posible realizar la lectura y escritura de datos a través de una interfaz bastante sencilla.\nEntre otras de las ventajas que ofrece el paquete {sf} podemos destacar:\n\nLos objetos sf son dataframe o tibbles, en los que los datos geográficos se encuentran en la última columna llamada geom o geometry\nLos procesos de lectura y escritura de datos geográficos son rápidos.\nEs posible leer y escribir objetos espaciales en BBDD espaciales como PostGIS.\nLos nombres de las funciones son consistentes e intuitivos, todos ellos empiezan por el prefijo st_\nLas funciones pueden combinarse usando el operador pipe %&gt;% (o |&gt; en R&gt;=4.1.0)\nEs compatible con tidyverse.\n\nR pone a nuestra disposición una amplia documentación de ayuda sobre este paquete que se puede encontrar en https://r-spatial.github.io/sf/index.html, o tecleando vignette(package = \"sf\")en la consola de RStudio2.\n\n\n2.1.3 La clase sfg. Tipos de geometrías\nLa clase sfg da soporte a los diferentes tipos de geometrías simple feature en R: punto, línea, polígono (y sus opciones “múltiples”) o colección de geometrías que constituyen los bloques de construcción básico. Aunque la situación habitual será importar un fichero con datos espaciales, conviene conocer el conjunto de funciones que nos permiten crear objetos geométricos de características simples. A pesar de exitir 17 tipos de geometría, aquí nos vamos a centrar en los siete más utilizados:\n\nPunto: es la geometría base, a partir de ella se construyen las demás. Los puntos son coordenadas en un espacio 2D, 3D o 4D. Si trabajamos en un espacio 3D, la tercera dimensión que añadimos es la altura. En un espacio 4D, la cuarta dimensión es una valor asociado al punto. Para definir un punto usaremos la función st_point(), a la que le pasaremos por parámetro las coordenadas del punto en forma de vector o tabla.\n\n\n# Definición de un punto con 2 dimensiones\npunto &lt;- st_point(c(2.5, 3.75))\nplot(punto, axes = TRUE)\n\n\n\n\n\n\n\n\n\nLínea: cualquier línea se define mediante las coordendas de sus vértices, entiendo por vértice cualquier punto en el que se produzca un cambio de pendiente de la recta, no solo los vértices inicial y final. Para la construcción de líneas contamos con la función st_line()de la clase Linestring. Dicha función espera recibir por parámetro las coordenadas de los vértices de la línea.\n\n\nx1 &lt;- c(0, 3, 5, 8, 10)\ny1 &lt;- c(0, 3, 4, 8, 10)\ncoords1 &lt;- cbind(x1, y1)\nline1 &lt;- st_linestring(coords1)\nplot(line1, axes = TRUE)\n\n\n\n\n\n\n\n\n\nPolígono: Los polígonos se definen mediante las coordenadas de los vértices de una geometría cerrada. Es decir, las coordenadas del primer vértice y el último deben ser las mismas. La clase que da sustento a la construcción de este tipo de objetos es Polygon mediante la función st_polygon(). Esta función espera que le pasemos por parámetro las coordenadas de los vértices de la geometría. Existe un convenio para dar el orden de los vértices. Para definir el contorno del polígono, debemos proporcionar los vértices en el sentido contrario a las agujas del reloj. Sin embargo, para definir un hueco en un polígono, debemos proporcionar los vértices del hueco en el sentido de las agujas del reloj.\n\n\n# Definición de 2 polígonos\n# Sentido contrario agujas del reloj\nx1 &lt;- c(0, 2, 6, 0, 0)\ny1 &lt;- c(4, 4, 10, 10, 4)\ncoords1 &lt;- cbind(x1, y1)\n# Sentido agujas del reloj (hueco)\nx2 &lt;- c(1, 1, 2, 2, 1)\ny2 &lt;- c(5, 6, 6, 5, 5)\ncoords2 &lt;- cbind(x2, y2)\npol &lt;- st_polygon(list(coords1, coords2))\nplot(pol, axes = TRUE)\n\n\n\n\n\n\n\n\n\nMultipunto: es una colección de puntos. Para poder considerar un mutipunto como un objeto sf, todos los puntos que lo componen deben ser diferentes. Podemos definir un multipunto mediante la función st_multipoint() pasándole por parámetro el vector de coordenadas de los puntos.\n\n\n# Definición de varios puntos con 2 dimensiones\ncx &lt;- c(2, 4, 6)\ncy &lt;- c(4, 7, 8)\ncoords &lt;- cbind(cx, cy)\nmpunto &lt;- st_multipoint(coords)\nplot(mpunto, axes = TRUE)\n\n\n\n\n\n\n\n\n\nMultilínea: es una colección de líneas. En la clase Multilinestring encontramos la función st_multilinestring(). Si le pasamos por parámetro una lista de varias líneas, construiremos una multilínea.\n\n\nx2 &lt;- c(2, 1, 1)\ny2 &lt;- c(2, 4, 5)\ncoords2 &lt;- cbind(x2, y2)\nline2 &lt;- st_linestring(coords2)\n\nx3 &lt;- c(8, 8)\ny3 &lt;- c(8, 5)\ncoords3 &lt;- cbind(x3, y3)\nline3 &lt;- st_linestring(coords3)\n\n# Construcción y representación de multilinestring\nlines &lt;- list(line1, line2, line3)\nml &lt;- st_multilinestring(lines)\nplot(ml, axes = TRUE)\n\n\n\n\n\n\n\n\n\nMultipolígono: es una colección de polígonos. Construimos un multipolígono mediante la función st_multipolygon() pasándole una lista con los polígonos que van a formar parte del multipolígono.\n\n\nx1 &lt;- c(0, 2, 6, 0, 0)\ny1 &lt;- c(4, 4, 10, 10, 4)\ncoords1 &lt;- cbind(x1, y1)\npol1 &lt;- st_polygon(list(coords1))\nx2 &lt;- c(0, 1, 1, 0, 0)\ny2 &lt;- c(2, 2, 3, 3, 2)\ncoords2 &lt;- cbind(x2, y2)\npol2 &lt;- st_polygon(list(coords2))\nmpol &lt;- st_multipolygon(list(pol1, pol2))\nplot(mpol, axes =  TRUE)\n\n\n\n\n\n\n\n\n\nColección: un objeto sf también puede ser una colección de geometrías de cualquiera de los tipos vistos, incluidas las opciones multiples.\n\n\n# Colección\ngeometria2 &lt;- st_geometrycollection(list(line1, line3, mpol))\nplot(geometria2, axes = TRUE)\n\n\n\n\n\n\n\n\nComo resumen de esta sección conviene destacar que los objetos sfg se pueden crear a partir de tres tipos de datos básicos:\n\nUn vector numérico (para el caso de un solo punto)\nUna matriz (para el caso de un conjunto de puntos), donde cada fila representa un punto, un multipunto o una cadena de líneas.\nUna lista (para el caso de una colección de objetos como matrices, multilíneas o colecciones de geometría).\n\n\n\n2.1.4 Objetos sfc\nUn objeto sfg solo puede contener geometrías simple feature, mientras que un objeto sfc es una columna simple feature. Es decir, se trata de una lista de objetos sfg, que además puede contener información sobre el sistema de referencia de coordenadas que usan. Usando la función st_sfc() podemos construir objetos sfc a partir de objetos sfg del mismo tipo o de distintos tipos. En la mayoría de los casos, un objeto sfc contendrá objetos del mismo tipo de geometría. Por ejemplo, si convertimos objetos sfg de tipo linestring a un objeto sfc, el resultado es un objeto sfc de tipo linestring.\n\n# Objeto sfc a partir de objetos sfg del mismo tipo -&gt; linestring\ngeom_sfcl &lt;- st_sfc(line1, line3)\ngeom_sfcl\n\nGeometry set for 2 features \nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 0 ymin: 0 xmax: 10 ymax: 10\nCRS:           NA\n\n\nLINESTRING (0 0, 3 3, 5 4, 8 8, 10 10)\n\n\nLINESTRING (8 8, 8 5)\n\nplot(geom_sfcl, axes = TRUE)\n\n\n\n\n\n\n\n\n\n# Objeto sfc a partir de objetos sfg del mismo tipo -&gt; polygon\ngeom_sfcp &lt;- st_sfc(pol1, pol2)\ngeom_sfcp\n\nGeometry set for 2 features \nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 0 ymin: 2 xmax: 6 ymax: 10\nCRS:           NA\n\n\nPOLYGON ((0 4, 2 4, 6 10, 0 10, 0 4))\n\n\nPOLYGON ((0 2, 1 2, 1 3, 0 3, 0 2))\n\nplot(geom_sfcp, axes = TRUE)\n\n\n\n\n\n\n\n\nTambién es posible crear un objeto sfc a partir de objetos sfg de distintos tipos de geometría:\n\n# Objeto sfc a partir de objetos sfg de distinto tipo\ngeom_sfc &lt;- st_sfc(line1, line3, mpol)\ngeom_sfc\n\nGeometry set for 3 features \nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: 0 ymin: 0 xmax: 10 ymax: 10\nCRS:           NA\n\n\nLINESTRING (0 0, 3 3, 5 4, 8 8, 10 10)\n\n\nLINESTRING (8 8, 8 5)\n\n\nMULTIPOLYGON (((0 4, 2 4, 6 10, 0 10, 0 4)), ((...\n\nplot(geom_sfc, axes = TRUE)\n\n\n\n\n\n\n\n# Remarquemos la diferencia con una colección de objetos sfg\ngeom_collection &lt;- st_geometrycollection(list(line1, line3, mpol))\ngeom_collection\n\nGEOMETRYCOLLECTION (LINESTRING (0 0, 3 3, 5 4, 8 8, 10 10), LINESTRING (8 8, 8 5), MULTIPOLYGON (((0 4, 2 4, 6 10, 0 10, 0 4)), ((0 2, 1 2, 1 3, 0 3, 0 2))))\n\nplot(geom_collection, axes = TRUE)\n\n\n\n\n\n\n\n\nComo se ha podido observar en los ejemplos anteriores, el valor predeterminado del sistema de referencia de coordenadas (CRS) es NA. Podemos verificarlo mediante la función st_crs().\n\nst_crs(geom_sfc)\n\nCoordinate Reference System: NA\n\n\nTodas las geometrías de un objeto sfc deben tener el mismo CRS. Podemos especificar el sistema de referencia de coordenadas al construir el objeto mediante el argumento crs de st_sfc().\n\n# Objeto sfc a partir de objetos sfg de distinto tipo y especificamos el CRS\ngeom_sfc_crs &lt;- st_sfc(line1, line3, mpol, crs = \"EPSG:4326\")\nst_crs(geom_sfc_crs)\n\nCoordinate Reference System:\n  User input: EPSG:4326 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n        MEMBER[\"World Geodetic System 1984 (Transit)\"],\n        MEMBER[\"World Geodetic System 1984 (G730)\"],\n        MEMBER[\"World Geodetic System 1984 (G873)\"],\n        MEMBER[\"World Geodetic System 1984 (G1150)\"],\n        MEMBER[\"World Geodetic System 1984 (G1674)\"],\n        MEMBER[\"World Geodetic System 1984 (G1762)\"],\n        MEMBER[\"World Geodetic System 1984 (G2139)\"],\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ENSEMBLEACCURACY[2.0]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n\n\n\n\n2.1.5 La clase sf\nEn las secciones anteriores hemos mostrado como se construyen objetos puramente geométricos, objetos sfg y sfc, que solo almancen información geográfica (coordenadas). A estos objetos podemos agregarles otras características o atributos. Pongamos un ejemplo, vamos a asociarle al punto de Londres una temperatura de 25 °C para el 21 de junio de 2017. Por un lado vamos a tener la geometría (las coordenadas) y, por otro lado, tres atributos con tres clases diferentes (nombre del lugar, temperatura y fecha). Mediante un objeto de la clase sf podemos representar la combinación de estos atributos (data.frame) junto con la columna de geometría (sfc). Para ello contamos con la función st_sf().\n\nlnd_point &lt;- st_point(c(0.1, 51.5))                 # Objeto sfg\nlnd_geom &lt;- st_sfc(lnd_point, crs = 4326)           # Objeto sfc \nlnd_attrib &lt;- data.frame(                           # Objeto data.frame\n  name = \"London\",\n  temperature = 25,\n  date = as.Date(\"2017-06-21\")\n  )\nlnd_sf &lt;- st_sf(lnd_attrib, geometry = lnd_geom)    # Objeto sf\n\nEn el siguiente fragmento de código podemos ver que los objetos sf en realidad tienen dos clases, sf y data.frame. Los objetos sf son data frames, pero con atributos espaciales almacenados en una columna de lista, generalmente llamada geometry. Por este motivo, un objeto sf puede tratarse y se comporta como un data.frame.\n\nlnd_sf\n\nSimple feature collection with 1 feature and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 0.1 ymin: 51.5 xmax: 0.1 ymax: 51.5\nGeodetic CRS:  WGS 84\n    name temperature       date         geometry\n1 London          25 2017-06-21 POINT (0.1 51.5)\n\nclass(lnd_sf)\n\n[1] \"sf\"         \"data.frame\"\n\n\n\n\n2.1.6 Lectura de simple feature\nLos formatos de ficheros de datos espaciales más comunes son shapefile y GEOJSON. El formato shapefile, desarrollado por la compañía ESRI (se dedica a la creacción y comercialización de software para Sistemas de Información Geográfica) es muy utilizado. Sin embargo, GEOJSON se ha centrado sobre todo en aplicaciones del entorno web. GeoPackage (GPKG) es otro formato definido por el Open Geospatial Consortium (OGC).\nEn un fichero shapefile se almacena la localización de elementos geográficos y las características o atributos asociados a ellos, en formato vectorial. Lo constituyen un conjunto de ficheros, entre los que podemos destacar:\n\n.shp: es el archivo que almacena los objetos geométricos\n.shx: es el archivo que almacena el índice de los objetos geométricos\n.dbf: es el archivo que contiene la tabla de los atributos de los objetos geométricos\n.prj: este archivo contiene información del sistema de coordenadas\n\nDesde sf podemos realizar la lectura de un fichero shapefile o GPKG mediante las funciones st_read() o read_sf(). El primer argumento que necesitan estas funciones, es una cadena de texto que contenga la ruta en la que se encuentra el fichero a leer. Desde sf es posible leer muchos tipos de ficheros de datos vectoriales, ya que de forma automática detecta la extensión del archivo y carga los drivers necesarios para interpretar la información que contiene el fichero. A continuación podremos realizar una simple representación estática mediante la función plot().\n\nvector_filepath &lt;- system.file(\"shapes/world.gpkg\", package = \"spData\")\nworld &lt;- read_sf(vector_filepath, quiet = TRUE)\n# Equivalente a: world &lt;- st_read(vector_filepath, as_tibble = TRUE)\nplot(world)\n\nWarning: plotting the first 9 out of 10 attributes; use max.plot = 10 to plot\nall\n\n\n\n\n\n\n\n\n\nEstas funciones también permiten leer solo partes de un archivo en la RAM. A continuación mostramos un par de ejemplos de como leer una porción de un archivo y una sola línea mediante el empleo de una consulta SQL. En el primer caso, a través de la consulta le indicamos que queremos obtener todas las columnas (SELECT *) de la capa “world” para la cual continent es igual a “Europe”. En el segundo caso, nos quedamos solo con la capa correspondiente a name_long = \"Spain\":\n\n# Podemos seleccionar un continente\neurope &lt;- st_read(vector_filepath,\n                  query = 'SELECT * FROM \"world\" WHERE continent = \"Europe\"')\n\nReading query `SELECT * FROM \"world\" WHERE continent = \"Europe\"'\nfrom data source `/home/jfelipe/R/x86_64-pc-linux-gnu-library/4.5/spData/shapes/world.gpkg' \n  using driver `GPKG'\nSimple feature collection with 39 features and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: 2.053389 xmax: 180 ymax: 81.2504\nGeodetic CRS:  WGS 84\n\nhead(europe)\n\nSimple feature collection with 6 features and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: 2.053389 xmax: 180 ymax: 81.2504\nGeodetic CRS:  WGS 84\n  iso_a2          name_long continent region_un       subregion\n1     RU Russian Federation    Europe    Europe  Eastern Europe\n2     NO             Norway    Europe    Europe Northern Europe\n3     FR             France    Europe    Europe  Western Europe\n4     SE             Sweden    Europe    Europe Northern Europe\n5     BY            Belarus    Europe    Europe  Eastern Europe\n6     UA            Ukraine    Europe    Europe  Eastern Europe\n               type   area_km2       pop  lifeExp gdpPercap\n1 Sovereign country 17018507.4 143819666 70.74366 25284.586\n2 Sovereign country   397994.6        NA       NA        NA\n3           Country   644847.9        NA       NA        NA\n4 Sovereign country   450581.6   9696110 82.25366 44167.632\n5 Sovereign country   208969.8   9474511 72.97073 17944.210\n6 Sovereign country   572549.0  45271947 71.18659  8243.474\n                            geom\n1 MULTIPOLYGON (((180 70.8322...\n2 MULTIPOLYGON (((15.14282 79...\n3 MULTIPOLYGON (((-51.6578 4....\n4 MULTIPOLYGON (((11.02737 58...\n5 MULTIPOLYGON (((28.17671 56...\n6 MULTIPOLYGON (((35.01266 45...\n\nplot(europe)\n\n\n\n\n\n\n\n# Podemos seleccionar un pais\nspain &lt;- read_sf(vector_filepath,\n                 query = 'SELECT * FROM \"world\" WHERE name_long = \"Spain\"')\nhead(spain)\n\nSimple feature collection with 1 feature and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -9.392884 ymin: 35.94685 xmax: 3.039484 ymax: 43.74834\nGeodetic CRS:  WGS 84\n# A tibble: 1 × 11\n  iso_a2 name_long continent region_un subregion   type  area_km2    pop lifeExp\n  &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;    &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;\n1 ES     Spain     Europe    Europe    Southern E… Sove…  502306. 4.65e7    83.2\n# ℹ 2 more variables: gdpPercap &lt;dbl&gt;, geom &lt;MULTIPOLYGON [°]&gt;\n\nplot(spain)\n\nWarning: plotting the first 9 out of 10 attributes; use max.plot = 10 to plot\nall\n\n\n\n\n\n\n\n\n\n\n\n2.1.7 Representación estática\nLos mapas básicos se crean en sf con plot(). Por defecto, esta opción crea un gráfico de varios paneles, en los que, cada panel contiene un gráfico secundario correspondiente a la representación de una variable del objeto. Si la variable que se está representando en un panel es continua, se incluirá por defecto una leyenda o “clave” con un color continuo si el objeto a trazar tiene una sola variable. Los colores también se pueden configurar con col=, aunque esto no creará una paleta continua o una leyenda. Utilizamos ahora los datos de países del paquete {rnaturalearth}.\n\nworld &lt;- ne_countries(scale = \"medium\", returnclass = \"sf\")\nclass(world)\n\n[1] \"sf\"         \"data.frame\"\n\nnames(world)\n\n  [1] \"featurecla\" \"scalerank\"  \"labelrank\"  \"sovereignt\" \"sov_a3\"    \n  [6] \"adm0_dif\"   \"level\"      \"type\"       \"tlc\"        \"admin\"     \n [11] \"adm0_a3\"    \"geou_dif\"   \"geounit\"    \"gu_a3\"      \"su_dif\"    \n [16] \"subunit\"    \"su_a3\"      \"brk_diff\"   \"name\"       \"name_long\" \n [21] \"brk_a3\"     \"brk_name\"   \"brk_group\"  \"abbrev\"     \"postal\"    \n [26] \"formal_en\"  \"formal_fr\"  \"name_ciawf\" \"note_adm0\"  \"note_brk\"  \n [31] \"name_sort\"  \"name_alt\"   \"mapcolor7\"  \"mapcolor8\"  \"mapcolor9\" \n [36] \"mapcolor13\" \"pop_est\"    \"pop_rank\"   \"pop_year\"   \"gdp_md\"    \n [41] \"gdp_year\"   \"economy\"    \"income_grp\" \"fips_10\"    \"iso_a2\"    \n [46] \"iso_a2_eh\"  \"iso_a3\"     \"iso_a3_eh\"  \"iso_n3\"     \"iso_n3_eh\" \n [51] \"un_a3\"      \"wb_a2\"      \"wb_a3\"      \"woe_id\"     \"woe_id_eh\" \n [56] \"woe_note\"   \"adm0_iso\"   \"adm0_diff\"  \"adm0_tlc\"   \"adm0_a3_us\"\n [61] \"adm0_a3_fr\" \"adm0_a3_ru\" \"adm0_a3_es\" \"adm0_a3_cn\" \"adm0_a3_tw\"\n [66] \"adm0_a3_in\" \"adm0_a3_np\" \"adm0_a3_pk\" \"adm0_a3_de\" \"adm0_a3_gb\"\n [71] \"adm0_a3_br\" \"adm0_a3_il\" \"adm0_a3_ps\" \"adm0_a3_sa\" \"adm0_a3_eg\"\n [76] \"adm0_a3_ma\" \"adm0_a3_pt\" \"adm0_a3_ar\" \"adm0_a3_jp\" \"adm0_a3_ko\"\n [81] \"adm0_a3_vn\" \"adm0_a3_tr\" \"adm0_a3_id\" \"adm0_a3_pl\" \"adm0_a3_gr\"\n [86] \"adm0_a3_it\" \"adm0_a3_nl\" \"adm0_a3_se\" \"adm0_a3_bd\" \"adm0_a3_ua\"\n [91] \"adm0_a3_un\" \"adm0_a3_wb\" \"continent\"  \"region_un\"  \"subregion\" \n [96] \"region_wb\"  \"name_len\"   \"long_len\"   \"abbrev_len\" \"tiny\"      \n[101] \"homepart\"   \"min_zoom\"   \"min_label\"  \"max_label\"  \"label_x\"   \n[106] \"label_y\"    \"ne_id\"      \"wikidataid\" \"name_ar\"    \"name_bn\"   \n[111] \"name_de\"    \"name_en\"    \"name_es\"    \"name_fa\"    \"name_fr\"   \n[116] \"name_el\"    \"name_he\"    \"name_hi\"    \"name_hu\"    \"name_id\"   \n[121] \"name_it\"    \"name_ja\"    \"name_ko\"    \"name_nl\"    \"name_pl\"   \n[126] \"name_pt\"    \"name_ru\"    \"name_sv\"    \"name_tr\"    \"name_uk\"   \n[131] \"name_ur\"    \"name_vi\"    \"name_zh\"    \"name_zht\"   \"fclass_iso\"\n[136] \"tlc_diff\"   \"fclass_tlc\" \"fclass_us\"  \"fclass_fr\"  \"fclass_ru\" \n[141] \"fclass_es\"  \"fclass_cn\"  \"fclass_tw\"  \"fclass_in\"  \"fclass_np\" \n[146] \"fclass_pk\"  \"fclass_de\"  \"fclass_gb\"  \"fclass_br\"  \"fclass_il\" \n[151] \"fclass_ps\"  \"fclass_sa\"  \"fclass_eg\"  \"fclass_ma\"  \"fclass_pt\" \n[156] \"fclass_ar\"  \"fclass_jp\"  \"fclass_ko\"  \"fclass_vn\"  \"fclass_tr\" \n[161] \"fclass_id\"  \"fclass_pl\"  \"fclass_gr\"  \"fclass_it\"  \"fclass_nl\" \n[166] \"fclass_se\"  \"fclass_bd\"  \"fclass_ua\"  \"geometry\"  \n\n# head(world) # Descomentar para imprimir vista inicial\nplot(world[3:6])\n\n\n\n\n\n\n\nplot(world[\"pop_est\"])\n\n\n\n\n\n\n\n\nEn ocasiones resulta útil representar solo una porción del data frame original.\n\nworld_asia &lt;- world[world$continent == \"Asia\", ]\n# head(world_asia) # Descomentar para imprimir vista\nplot(world_asia)\n\nWarning: plotting the first 9 out of 168 attributes; use max.plot = 168 to plot\nall\n\n\n\n\n\n\n\n\nplot(world_asia[\"pop_est\"])\n\n\n\n\n\n\n\n\nEn el siguiente ejemplo mostramos como destacar un pais sobre este continente.\n\nindia &lt;- world[world$name_long == \"India\", ]\nplot(st_geometry(india), \n     expandBB = c(0, 0.2, 0.1, 1), \n     col = \"gray\", \n     lwd = 3)\nplot(world_asia[0], add = TRUE)\n\n\n\n\n\n\n\n\nLa función plot() es rápida de ejecutar y requiere pocas líneas de código. Sin embargo, las gráficas que genera son un tanto simples. Podemos conseguir representaciones estáticas mucho más elaboradas si usamos la función geom_sf() del paquete {ggplot2}.\n\nggplot(data = world) +\n  geom_sf(aes(fill = pop_est)) +\n  scale_fill_gradient(low = \"lightblue\", high = \"blue\")",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datos espaciales</span>"
    ]
  },
  {
    "objectID": "02-datos-espaciales.html#datos-raster-y-cubos-de-datos-vectoriales",
    "href": "02-datos-espaciales.html#datos-raster-y-cubos-de-datos-vectoriales",
    "title": "2  Datos espaciales",
    "section": "2.2 Datos raster y cubos de datos vectoriales",
    "text": "2.2 Datos raster y cubos de datos vectoriales\n\nEl paquete stars ofrece soporte para representación y manejo de datos raster (por ejemplo, de imágenes satelitales) así como cubos de datos vectoriales (vector datacubes), tal y como muestra la Figura 2.1.\n\n\n\n\n\n\n\nFigura 2.1: Los hipercubos de datos son cubos de varias dimensiones que pueden contener datos de: latitud y longitud, tiempo, distintas bandas y diferentes sensores. Fuente: https://r-spatial.github.io/stars/.\n\n\n\n\nEl paquete terra incluye numerosas herramientas para procesado y análisis de datos espaciales, incluyendo manipulación de objetos raster.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datos espaciales</span>"
    ]
  },
  {
    "objectID": "02-datos-espaciales.html#el-paquete-terra",
    "href": "02-datos-espaciales.html#el-paquete-terra",
    "title": "2  Datos espaciales",
    "section": "2.3 El paquete {terra}",
    "text": "2.3 El paquete {terra}\n\n2.3.1 Introdución\nEl modelo de datos ráster se utiliza comúnmente para representar fenómenos espacialmente continuos como, por ejemplo, la temperatura o la densidad de población. Este modelo represetna el mundo real mediante una cuadrícula de rectángulos de igual tamaño (denominados celdas o, en el contexto de la teledetección por satélite, píxeles).\nGeneralmente, los datos raster constan de un encabezado y una matriz (con filas y columnas) cuyas celdas están igualmente espaciadas. El encabezado define el sistema de referencia de coordenadas, la extensión y el origen. Lo habitual es que el origen (o punto de partida) sea la coordenada de la esquina inferior izquierda de la matriz, aunque algunos paquetes, como el paquete {terra}, designan para este fin la esquina superior izquierda. El encabezado define la extensión a través del número de columnas, el número de filas y la resolución del tamaño de celda. Por lo tanto, comenzando desde el origen, podemos acceder fácilmente y modificar cada celda usando el ID de una celda o especificando explícitamente las filas y columnas.\nLa principal ventaja de esta representación matricial es que evita almacenar explícitamente las coordenadas de las cuatro esquinas (de hecho, solo almacena una coordenada, la del origen) de cada celda, a diferencia del caso de los polígonos vectoriales rectangulares. Ésto, junto con el álgebra de mapas, hacen que el procesamiento de ráster sea mucho más eficiente y rápido que el procesamiento de datos vectoriales. Sin embargo, a diferencia de los datos vectoriales, la celda de una capa ráster solo puede contener un valor, que puede ser numérico o categórico.\n\n\n\n\n\n\nFigura 2.2: Figura tomada de (Lovelace et al., 2019), sección 2.3.\n\n\n\nAunque el modelo de datos ráster se utiliza para representar fenómenos continuos, también es posible representar características discretas como el suelo o las clases de cobertura terrestre, la única diferencia es que, en este caso, los bordes discretos de estas características se vuelven borrosos. En general, cuando se trabaja con características discretas, resulta mucho más adecuada una representación vectorial.\n\n\n\n\n\n\nFigura 2.3: Figura tomada de (Lovelace et al., 2019), sección 2.3.\n\n\n\nR cuenta con varios paquetes capaces de leer y procesar datos ráster, siendo los más utilizados {terra} y {stars}. En este curso, nos centramos en el paquete {terra}. Como características principales podemos destacar:\n\nFue creado por Robert Hijmans, al igual que su predecesor, el paquete {raster}.\nTrabaja con el modelo de datos ráster de cuadrículas regulares.\nPuede manejar rasters de una o varias capas, teniendo en cuenta que todos los elementos deben tener las mismas dimensiones espaciales y extensión.\nPuede leer datos ráster en la memoria o simplemente leer sus metadatos. Generalmente, esta operación se hace automáticamente en función del tamaño del archivo de entrada.\nUsa su propia clase de objetos para datos vectoriales, llamada SpatVector.\n\nEl paquete {terra} ofrece un amplio conjunto de funciones para crear, leer, exportar, manipular y procesar datasets ráster. Su funcionalidad, en gran medida, es la misma que la del paquete {raster}, pero con la ventaja añadida de que las funciones de {terra} suelen ser más eficientes, desde el punto de vista computacional, que sus equivalentes en {raster}. Al igual que con {sf} y {sp}, se pueden realizar traducciones sin problemas entre los dos tipos de objetos para garantizar la compatibilidad con versiones anteriores.\n\n\n2.3.2 SpatRaster\nA diferencia de los datos vectoriales, en los datos ráster la geometría no se almacena explícitamente como coordenadas. Se establece implícitamente conociendo la extensión espacial y el número de filas y columnas en las que se divide el área. A partir de la extensión y el número de filas y columnas, se puede calcular el tamaño de las celdas ráster (resolución espacial). Si bien las celdas ráster se pueden considerar como un conjunto de polígonos regulares, sería muy ineficiente representar los datos de esa manera, ya que las coordenadas de cada celda tendrían que almacenarse explícitamente. Hacerlo también aumentaría drásticamente el tiempo de procesamiento.\nVamos a ver un ejemplo de creación de un objeto SpatRaster desde cero, aunque lo normal es crear estos objetos a partir de un archivo.\n\n# Indicamos numero de columnas, filas y extension\nr &lt;- rast(ncol = 10, nrow = 10, \n          xmin = 10, xmax = 70, \n          ymin = 10, ymax = 50)\nr\n\nclass       : SpatRaster \nsize        : 10, 10, 1  (nrow, ncol, nlyr)\nresolution  : 6, 4  (x, y)\nextent      : 10, 70, 10, 50  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \n\n# ¿¿¿Que ocurre???\nplot(r)\n\n\n\n\n\n\n\n\nComo puede observarse, el objeto r solo tiene la geometría de un conjunto de datos ráster. Es decir, le hemos proporcionado una ubicación y resolución, pero no tiene valores asociados. Vamos a asignarle algunos valores. Para ello generamos ncell valores aleatorios a partir de una distribución uniforme y se los asignamos a nuestro ráster r mediante la función values().\n\n# Asignación de valores\nvalues(r) &lt;- runif(ncell(r))\nr\n\nclass       : SpatRaster \nsize        : 10, 10, 1  (nrow, ncol, nlyr)\nresolution  : 6, 4  (x, y)\nextent      : 10, 70, 10, 50  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \nsource(s)   : memory\nname        :      lyr.1 \nmin value   : 0.04230678 \nmax value   : 0.99601183 \n\nplot(r)\n\n\n\n\n\n\n\n\nUna forma sencilla de crear un objeto multi-layer es utilizando el método c(). Al representar el ráster multi-layer, obtendremos una gráfica por cada capa.\n\nr2 &lt;- r * r\nr3 &lt;- sqrt(r)\nr4 &lt;- r + r\ns &lt;- c(r, r2, r3, r4)\ns\n\nclass       : SpatRaster \nsize        : 10, 10, 4  (nrow, ncol, nlyr)\nresolution  : 6, 4  (x, y)\nextent      : 10, 70, 10, 50  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \nsource(s)   : memory\nnames       :      lyr.1,       lyr.1,     lyr.1,      lyr.1 \nmin values  : 0.04230678, 0.001789863, 0.2056861, 0.08461355 \nmax values  : 0.99601183, 0.992039557, 0.9980039, 1.99202365 \n\nplot(s)\n\n\n\n\n\n\n\n\nCuando añadimos varias capas, es conveniente darles un nombre diferente mediante la función names().\n\nnames(s) &lt;- c('layer1', 'layer2', 'layer3', 'layer4')\ns\n\nclass       : SpatRaster \nsize        : 10, 10, 4  (nrow, ncol, nlyr)\nresolution  : 6, 4  (x, y)\nextent      : 10, 70, 10, 50  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \nsource(s)   : memory\nnames       :     layer1,      layer2,    layer3,     layer4 \nmin values  : 0.04230678, 0.001789863, 0.2056861, 0.08461355 \nmax values  : 0.99601183, 0.992039557, 0.9980039, 1.99202365 \n\nplot(s)\n\n\n\n\n\n\n\n\nOtras funciones interesantes a la hora de construir nuestro propio ráster o de tabajar con objetos ráster son:\n\nncol(): indica el número de columnas\nnrow() indica el número de filas\nncell(): indica el número de celdas\nres(): indica la resolución en X e Y\ndim(): indica la dimensión (número de columnas, filas y capas)\n\n\nncol(s) \n\n[1] 10\n\nnrow(s)\n\n[1] 10\n\nncell(s)\n\n[1] 100\n\nres(s)\n\n[1] 6 4\n\ndim(s)\n\n[1] 10 10  4\n\n\nPara más información, podeís consultar la documentación oficial o la ayuda de RStudio.\n\n\n2.3.3 Lectura de datos raster\nAl igual que los datos vectoriales, los datos ráster vienen en muchos formatos de archivo y algunos de ellos admiten archivos multicapa. Uno de estos formatos es el archivo de imagen TIF. La función rast() de {terra} nos permite leer ficheros de datos ráster tanto de una capa como de varias. Veamos algunos ejemplos usando los datasets de {spDataLarge}.\n\n# Fichero raster de 1 capa\nraster_filepath &lt;- system.file(\"raster/srtm.tif\", \n                               package = \"spDataLarge\")\nsingle_layer &lt;- rast(raster_filepath)\nsingle_layer\n\nclass       : SpatRaster \nsize        : 457, 465, 1  (nrow, ncol, nlyr)\nresolution  : 0.0008333333, 0.0008333333  (x, y)\nextent      : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : srtm.tif \nname        : srtm \nmin value   : 1024 \nmax value   : 2892 \n\nplot(single_layer)\ntitle(main = \"Zion National Park\")\n\n\n\n\n\n\n\n\n\n# Fichero raster de 4 capas\nmultilayer_filepath &lt;- system.file(\"raster/landsat.tif\", \n                                   package = \"spDataLarge\")\nmultilayer_rast &lt;- rast(multilayer_filepath)\nmultilayer_rast\n\nclass       : SpatRaster \nsize        : 1428, 1128, 4  (nrow, ncol, nlyr)\nresolution  : 30, 30  (x, y)\nextent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / UTM zone 12N (EPSG:32612) \nsource      : landsat.tif \nnames       : landsat_1, landsat_2, landsat_3, landsat_4 \nmin values  :      7550,      6404,      5678,      5252 \nmax values  :     19071,     22051,     25780,     31961 \n\nplot(multilayer_rast)\n\n\n\n\n\n\n\n\n\n\n2.3.4 Representación estática\nAunque ya hemos mostrado algún ejemplo de representación gráfica, en esta sección completaremos algunos aspectos más sobre este tema. Vamos a trabajar con el dataset de Luxemburgo del paquete {terra}. Empezaremos realizando una representación sencilla de la geometría, que creamos con la función vect().\n\nfilename &lt;- system.file(\"ex/lux.shp\", \n                        package = \"terra\")\nbasename(filename)\n\n[1] \"lux.shp\"\n\nraster_file &lt;- vect(filename)\nraster_file\n\n class       : SpatVector \n geometry    : polygons \n dimensions  : 12, 6  (geometries, attributes)\n extent      : 5.74414, 6.528252, 49.44781, 50.18162  (xmin, xmax, ymin, ymax)\n source      : lux.shp\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       :  ID_1   NAME_1  ID_2   NAME_2  AREA       POP\n type        : &lt;num&gt;    &lt;chr&gt; &lt;num&gt;    &lt;chr&gt; &lt;num&gt;     &lt;num&gt;\n values      :     1 Diekirch     1 Clervaux   312 1.808e+04\n                   1 Diekirch     2 Diekirch   218 3.254e+04\n                   1 Diekirch     3  Redange   259 1.866e+04\n\nplot(raster_file)\n\n\n\n\n\n\n\n\nAl contener información sobre varias variables, podemos elegir qué variable queremos ver representada sobre la geometría. Por ejemplo, vamos a representar los valores de población y de área.\n\nlibrary(\"viridis\")\n\nCargando paquete requerido: viridisLite\n\n# Representación de una variable\nplot(raster_file, \"POP\")\n\n\n\n\n\n\n\n# Representación de varias variables\nplot(raster_file, c(\"POP\", \"AREA\"), col = viridis(10))\n\n\n\n\n\n\n\n\nTambién podemos hacer una matriz de figuras con la función par() y representar las gráficas ajustando el espaciado, colocando las leyendas dentro del área del mapa y poniendo el texto del eje Y en horizontal.\n\npar(mfrow = c(1,2))\nm &lt;- c(3.1, 3.1, 2.1, 2.1)\nplot(raster_file, \"POP\", col = viridis(10), mar = m, \n     plg = list(x = \"topright\"), \n     pax = list(las = 1))\nplot(raster_file, \"AREA\", col = viridis(10), mar = m, \n     plg = list(x = \"topright\", cex=.75),\n     pax = list(las = 1))\n\n\n\n\n\n\n\n\nLa visualización predeterminada de un SpatRaster de una sola capa depende del tipo de datos, pero siempre habrá una leyenda.\n\npar(mfrow = c(1, 1))\nf &lt;- system.file(\"ex/elev.tif\", \n                 package = \"terra\")\nr &lt;- rast(f)\nr\n\nclass       : SpatRaster \nsize        : 90, 95, 1  (nrow, ncol, nlyr)\nresolution  : 0.008333333, 0.008333333  (x, y)\nextent      : 5.741667, 6.533333, 49.44167, 50.19167  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : elev.tif \nname        : elevation \nmin value   :       141 \nmax value   :       547 \n\nplot(r)\n\n\n\n\n\n\n\n\nPodemos realizar un tipo diferente de representación, por ejemplo, por intervalos.\n\nm &lt;- c(3.1, 3.1, 1.1, 1.1)\nplot(r, type = \"interval\", \n     plg = list(x = \"topright\"), \n     mar = m)",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datos espaciales</span>"
    ]
  },
  {
    "objectID": "02-datos-espaciales.html#datos-de-españa",
    "href": "02-datos-espaciales.html#datos-de-españa",
    "title": "2  Datos espaciales",
    "section": "2.4 Datos de España",
    "text": "2.4 Datos de España\nTenemos la enorme suerte de que en nuestro país existe una comunidad muy activa que desarrolla múltiples paquetes R con información cartográfica, datos climáticos y de otra índole, ya preparados y perfectamente integrados con el resto de paquetes populares como ggplot2. Destacan:\n\nmapSpain: facilita la creación de mapas de diferentes niveles administrativos de España. Incluye muchas herramientas, como por ejemplo una función para representar las regiones como cuadrados o hexágonos de forma esquemática, siguiendo una idea parecida a los gráficos creados por el paquete statebins. Estos son una alternativa simplificada a los mapas de coropletas.\nclimaemet: permite utilizar la API de datos de la AEMET, integrándolos de forma directa en nuestro flujo de trabajo con R. Es imprescindible conseguir previamente una API KEY\n\n\n# Instala los paquetes sf y climaemet previamente\n\n# Ejecuta una sola vez para obtener tu API key:\n# aemet_api_key(apikey, overwrite = FALSE, install = FALSE)\n\nlibrary(climaemet)\nlibrary(ggplot2)\nlibrary(dplyr)\n\nall_stations &lt;- aemet_daily_clim(\n  start = \"2021-01-08\", end = \"2021-01-08\",\n  return_sf = TRUE\n)\n\nggplot(all_stations) +\n  geom_sf(aes(colour = tmed), shape = 19, size = 2, alpha = 0.95) +\n  labs(\n    title = \"Average temperature in Spain\",\n    subtitle = \"8 Jan 2021\",\n    color = \"Max temp.\\n(celsius)\",\n    caption = \"Source: AEMET\"\n  ) +\n  scale_colour_gradientn(\n    colours = hcl.colors(10, \"RdBu\", rev = TRUE),\n    breaks = c(-10, -5, 0, 5, 10, 15, 20),\n    guide = \"legend\"\n  ) +\n  theme_bw() +\n  theme(\n    panel.border = element_blank(),\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\")\n  )\n\n\n\n\n\n\n\nFigura 2.4: Representación de la temperatura máxima en distintos puntos de España en un día (2021-01-08). Fuente: https://ropenspain.github.io/climaemet/.\n\n\n\n\nairqualityES: datos diarios de medidas de calidad del aire en España en un periodo de 18 años (2001-2018), incluyendo varios agentes contaminantes. Los datos son publicados por el Gobierno de España en abierto.\n\n\n\n\n\nLovelace, R., Nowosad, J., & Muenchow, J. (2019). Geocomputation with R. Chapman; Hall/CRC.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datos espaciales</span>"
    ]
  },
  {
    "objectID": "02-datos-espaciales.html#footnotes",
    "href": "02-datos-espaciales.html#footnotes",
    "title": "2  Datos espaciales",
    "section": "",
    "text": "El resto se pueden instalar desde CRAN usando el panel Packages de RStudio o la función install.packages con el repositorio por defecto. Algunos paquetes tienen muchas dependencias y pueden tardar. Si después de la instalación alguno de los paquetes no se carga, comprueba que en la instalación no se produjeron errores.↩︎\nUna versión mejor de las viñetas, como indica el autor, se encuentran en https://r-spatial.github.io/sf/articles/↩︎",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datos espaciales</span>"
    ]
  },
  {
    "objectID": "03-visualizacion-basica.html",
    "href": "03-visualizacion-basica.html",
    "title": "3  Visualización básica",
    "section": "",
    "text": "3.0.1 Datos de ejemplo\nEn este capítulo presentamos algunas herramientas básicas de visualización en R, que se pueden aplicar a la creación de gráficos con datos espaciales.\nUtilizaremos un dataset de ejemplo del paquete R agridat (Wright, 2024), que contiene conjuntos de datos provenientes de publicaciones relacionadas con la agricultura, incluyendo cultivos de campo, cultivos arbóreos o estudios con animales, entre otros.\nTambién usaremos un dataset de ejemplo de un completo libro sobre métodos de regresión, ya en su segunda edición (Fahrmeir et al., 2022). Los archivos con los datasets de ejemplo de esta referencia se pueden descargar de su página web, así como también los archivos de código con los modelos sobre estos datos, en R.\nPaquete agridat\nlibrary(agridat)\n\ndata(holland.arthropods)\nstr(holland.arthropods)\n\n'data.frame':   63 obs. of  8 variables:\n $ row          : int  1 1 1 1 1 1 1 2 2 2 ...\n $ col          : int  1 2 3 4 5 6 7 1 2 3 ...\n $ n.brevicollis: int  6 3 3 2 1 2 1 10 12 1 ...\n $ linyphiidae  : int  67 114 59 80 102 169 63 106 64 41 ...\n $ collembola   : int  85 30 56 36 110 38 19 65 38 260 ...\n $ carabidae    : int  35 24 18 9 13 14 14 18 32 14 ...\n $ lycosidae    : int  13 22 20 32 28 12 43 28 8 3 ...\n $ weedcover    : int  42 23 17 21 12 15 13 27 9 10 ...\nDataset beech\nDe acuerdo con la información facilitada en (Fahrmeir et al., 2022), este dataset proviene de un proyecto para comprobar las condiciones en que se encuentra el bosque the Rothenbuch (Spessart), realizado por Axel Göttlein (Tech. Univ., Munich) desde 1982. En este caso, las localizaciones de los árboles examinados están mucho más próximas entre sí de lo habitual en los análisis oficiales a gran escala. Se examinaron árboles en 83 ubicaciones diferentes alrededor de la localidad, centrándose en cinco especies: haya, roble, abeto, alerce y pino. El archivo de datos está restringido a la información sobre las hayas. En concreto, cada año la salud de las hayas se categoriza mediante la variable respuesta defoliation (defoliación), medida en 9 niveles diferentes. La interpretación de los posibles valores es que 0% corresponde a un árbol sano y 100% se asigna a un arbol muerto.\nlibrary(Hmisc)\n\n\nAdjuntando el paquete: 'Hmisc'\n\n\nThe following objects are masked from 'package:base':\n\n    format.pval, units\n\nlibrary(readr)\n\nbeech &lt;- read_table(\"data/beech.raw\",\n  col_types = cols(id = col_integer(), year = col_integer(), age = col_integer(),\n                   canopyd = col_integer(), gradient = col_integer(),\n                   alt = col_integer(), depth = col_integer(), ph = col_double(),\n                   watermoisture = col_factor(levels = c(\"1\", \"2\", \"3\")),\n                   alkali = col_factor(levels = c(\"1\",\"2\", \"3\", \"4\")),\n                   humus = col_factor(levels = c(\"0\", \"1\", \"2\", \"3\", \"4\",\n                                                 \"5\", \"6\", \"7\", \"8\", \"9\")),\n                   type = col_factor(levels = c(\"0\",\"1\")),\n                   fert = col_factor(levels = c(\"0\",\"1\"))\n                   ))\nstr(beech)\n\nspc_tbl_ [1,796 × 16] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ id           : int [1:1796] 5 5 5 5 5 5 5 5 5 5 ...\n $ year         : int [1:1796] 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 ...\n $ defol        : num [1:1796] 0 0 0 0 0 0 0 0 0 0 ...\n $ x            : num [1:1796] 1.5 1.5 1.5 1.5 1.5 1.5 1.5 1.5 1.5 1.5 ...\n $ y            : num [1:1796] 5 5 5 5 5 5 5 5 5 5 ...\n $ age          : int [1:1796] 43 44 45 46 47 48 49 50 51 52 ...\n $ canopyd      : int [1:1796] 100 100 100 100 100 100 100 100 100 100 ...\n $ gradient     : int [1:1796] 2 2 2 2 2 2 2 2 2 2 ...\n $ alt          : int [1:1796] 320 320 320 320 320 320 320 320 320 320 ...\n $ depth        : int [1:1796] 10 10 10 10 10 10 10 10 10 10 ...\n $ ph           : num [1:1796] 4.61 4.34 4.75 3.99 5.3 3.83 4.05 4.06 4.3 4.84 ...\n $ watermoisture: Factor w/ 3 levels \"1\",\"2\",\"3\": 1 1 1 1 1 1 1 1 1 1 ...\n $ alkali       : Factor w/ 4 levels \"1\",\"2\",\"3\",\"4\": 3 3 3 3 3 3 3 3 3 3 ...\n $ humus        : Factor w/ 10 levels \"0\",\"1\",\"2\",\"3\",..: 3 5 2 4 2 1 1 3 1 1 ...\n $ type         : Factor w/ 2 levels \"0\",\"1\": 2 2 2 2 2 2 2 2 2 2 ...\n $ fert         : Factor w/ 2 levels \"0\",\"1\": 2 2 2 2 2 2 2 2 2 2 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   id = col_integer(),\n  ..   year = col_integer(),\n  ..   defol = col_double(),\n  ..   x = col_double(),\n  ..   y = col_double(),\n  ..   age = col_integer(),\n  ..   canopyd = col_integer(),\n  ..   gradient = col_integer(),\n  ..   alt = col_integer(),\n  ..   depth = col_integer(),\n  ..   ph = col_double(),\n  ..   watermoisture = col_factor(levels = c(\"1\", \"2\", \"3\"), ordered = FALSE, include_na = FALSE),\n  ..   alkali = col_factor(levels = c(\"1\", \"2\", \"3\", \"4\"), ordered = FALSE, include_na = FALSE),\n  ..   humus = col_factor(levels = c(\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"), ordered = FALSE, include_na = FALSE),\n  ..   type = col_factor(levels = c(\"0\", \"1\"), ordered = FALSE, include_na = FALSE),\n  ..   fert = col_factor(levels = c(\"0\", \"1\"), ordered = FALSE, include_na = FALSE)\n  .. )\n\n# Para un resumen más completo:\n# Hmisc::html(describe(beech))",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Visualización básica</span>"
    ]
  },
  {
    "objectID": "03-visualizacion-basica.html#el-paquete-ggplot2",
    "href": "03-visualizacion-basica.html#el-paquete-ggplot2",
    "title": "3  Visualización básica",
    "section": "3.1 El paquete ggplot2",
    "text": "3.1 El paquete ggplot2",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Visualización básica</span>"
    ]
  },
  {
    "objectID": "03-visualizacion-basica.html#anatomía-de-un-gráfico-con-ggplot2",
    "href": "03-visualizacion-basica.html#anatomía-de-un-gráfico-con-ggplot2",
    "title": "3  Visualización básica",
    "section": "3.2 Anatomía de un gráfico con ggplot2",
    "text": "3.2 Anatomía de un gráfico con ggplot2\nEl paquete ggplot2 sigue los principios de la gramática de gráficos que hemos visto en el ?sec-grammar-of-graphics, de forma que nos permite construir un gráfico paso a paso. Para ello se empieza por utilizar la función ggplot():\n\nIndicamos a la función ggplot() los datos que vamos a representar. \nIndicamos a ggplot() qué relaciones queremos visualizar. \nElegimos cómo queremos representar gráficamente las relaciones en nuestros datos que hemos indicado en el paso anterior. \nSi es necesario, superponemos más elementos gráficos (objetos geométricos o geoms), añadiéndolas a nuestro gráfico una a una.\nIncluimos funciones adicionales para ajustar transformar los datos, ajustar o cambiar escalas, añadir etiquetas y título, marcas en los ejes, capas adicionales, etc.\n\nEl argumento data = ....El argumento mapping = aes(...).Elegimos una función geom_...() que determina el tipo de gráfico o elemento gráfico.Veamos estós datos sobre un esquema para hacernos una idea más clara del aspecto que tendrá nuestro código.\n1ggplot(data = &lt;DATOS&gt;,\n       mapping = aes(&lt;CONEXIONES&gt;)) +\n2  geom_...(...) +\n3  stat_...(...) +\n4  &lt;FUNCIONES DE ESCALA Y GUÍAS&gt; +\n5  &lt;SISTEMAS COORDENADOS&gt; +\n6  &lt;FACETAS&gt; +\n7  &lt;TEMA&gt;\n\n1\n\nIndicamos qué datos vamos a utilizar y como conectamos esos datos (mapeo) con los elementos estéticos. Esta parte es obligatoria.\n\n2\n\nAñadimos uno o varios objetos geométricos para representar los datos.\n\n3\n\nTransformamos los datos (funciones stat_...()), normalmente resumiéndolos de algún modo.\n\n4\n\nAjustamos el mapeo de los datos a los elementos estéticos, modificando la escala de representación o añadiendo elementos de guía para intepretar el gráfico (marcas en ejes, leyenda, etc.).\n\n5\n\nConfiguramos el sistema coordenado de representación (por defecto se usan coordenadas cartesianas): intercambio de ejes X e Y (función coord_flip()), uso de coordenadas polares (coord_polar()), etc.\n\n6\n\nDecidimos si queremos desglosar el gráfico en varios paneles (facets) para presentar simultáneamente varios subgráficos (como hemos visto, útil para comparar entre grupos, evolución temporal y en otros casos).\n\n7\n\nPor último, podemos elegir un tema preconfigurado que adapta el aspecto de muchos de los elementos del gráfico para conseguir un resultado final más armonizado.\n\n\n\n\n\n\n\n\nInformación adicional sobre ggplot2\n\n\n\n\n\nSi necesitas más información sobre la utilización del paquete ggplot2 te recomendamos que consultes las siguientes referencias:\n\nCapítulo 5 de nuestro curso previo Visualización de Datos con R, para este mismo programa de doctorado.\nManual oficial de ggplot2: https://ggplot2-book.org (3ª ed., en progreso).",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Visualización básica</span>"
    ]
  },
  {
    "objectID": "03-visualizacion-basica.html#taller-práctico-1-visualización-de-datos-espaciales-con-ggplot2",
    "href": "03-visualizacion-basica.html#taller-práctico-1-visualización-de-datos-espaciales-con-ggplot2",
    "title": "3  Visualización básica",
    "section": "3.3 Taller práctico 1: visualización de datos espaciales con ggplot2",
    "text": "3.3 Taller práctico 1: visualización de datos espaciales con ggplot2\nVamos a utilizar el dataset beech, con datos sobre el estado de salud de las hayas cerca de la localidad alemana de Rothenbuch (Spessart), para componer otros ejemplos de construcción de gráficos para visualización de datos paso a paso con ggplot2.\n\nlibrary(ggplot2)\n\nbeech_years &lt;- beech |&gt;\n               dplyr::filter(year == 1983 | year == 1987 |\n                      year == 1991 | year == 1995 |\n                      year == 1999 | year == 2004)\n\np_beech &lt;- ggplot(data = beech_years,\n                  aes(x = x, y = y,\n                      color = defol, size = age)) +\n           geom_point(alpha = 0.6) +\n           facet_wrap(~year, nrow = 3) +\n           theme(\n            legend.text = element_text(size = 12),\n            legend.title = element_text(size = 14),\n            strip.text = element_text(size = 12),\n            axis.text = element_text(size = 12),\n            axis.title = element_text(size = 14),\n            \n           )\np_beech\n\n\n\n\n\n\n\nFigura 3.1: Visualización utilizando dos canales y facetas.\n\n\n\n\n\n\np_beech &lt;- ggplot(data = beech_years,\n                  aes(x = x, y = y,\n                      color = defol, size = age)) +\n           geom_point(aes(shape = alkali), alpha = 0.6) +\n           facet_wrap(~year, nrow = 3) +\n           theme(\n            legend.text = element_text(size = 12),\n            legend.title = element_text(size = 14),\n            strip.text = element_text(size = 12),\n            axis.text = element_text(size = 12),\n            axis.title = element_text(size = 14)\n           )\np_beech\n\n\n\n\n\n\n\nFigura 3.2: Visualización utilizando tres canales y facetas.\n\n\n\n\n\n\n\n\n\nFahrmeir, L., Kneib, T., Lang, S., & Marx, B. D. (2022). Regression: Models, Methods and Applicatons (2.ª ed.). Springer-Verlag GmbH. https://doi.org/10.1007/978-3-662-63882-8\n\n\nHolland, J. M., Perry, J. N., & Winder, L. (1999). The within-field spatial and temporal distribution of arthropods within winter wheat. Bulletin of Entomological Research, 89, 499-513. https://doi.org/10.1017/S0007485399000656\n\n\nWright, K. (2024). agridat: Agricultural Datasets. https://CRAN.R-project.org/package=agridat",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Visualización básica</span>"
    ]
  },
  {
    "objectID": "04-visualizacion-avanzada.html",
    "href": "04-visualizacion-avanzada.html",
    "title": "4  Visualización avanzada",
    "section": "",
    "text": "4.1 Representación de datos espaciales\nDominic Royé ha creado recientemente un taller titulado Breve introducción a la cartografía con R, que muestra algunos ejemplos básicos sobre cómo manejar este tipo de datos.\nPor supuesto, se pueden realizar todo tipo de representaciones más clásicas, como los mapas de coropletas en versión estática (Figura 4.3) como interactiva (Figura 4.4), utilizando la biblioteca JavaScript Leaflet.\nlibrary(tidyverse)\nlibrary(sf)\nsystem.file(\"gpkg/nc.gpkg\", package=\"sf\") |&gt;\n    read_sf() -&gt; nc\nnc.32119 &lt;- st_transform(nc, 'EPSG:32119')\nnc.32119 |&gt;\n    select(BIR74) |&gt;\n    plot(graticule = TRUE, axes = TRUE)\n\n\n\n\n\n\n\nFigura 4.3: Mapa de coropletas clásico mostrando nacimientos en 1974 en los condados del estado de Carolina del Norte (EE.UU.). Fuente: https://r-spatial.org/book/01-hello.html.\nlibrary(mapview) |&gt; suppressPackageStartupMessages()\nmapviewOptions(fgb = FALSE)\nnc.32119 |&gt; mapview(zcol = \"BIR74\", legend = TRUE, col.regions = sf.colors)\n\n\n\n\n\n\n\nFigura 4.4: Mapa de coropletas interactivo usando Leaflet. Fuente: https://r-spatial.org/book/01-hello.html.",
    "crumbs": [
      "Visualización avanzada",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualización avanzada</span>"
    ]
  },
  {
    "objectID": "04-visualizacion-avanzada.html#representación-de-datos-espaciales",
    "href": "04-visualizacion-avanzada.html#representación-de-datos-espaciales",
    "title": "4  Visualización avanzada",
    "section": "",
    "text": "Figura 4.1: Representación gráfica de la red de ríos de la cuenca hidrográfica del Ebro. El grosor de línea se corresponde con el caudal promedio de cada río. Fuente: https://github.com/dominicroye/Taller_Carto_RqueR_2024.\n\n\n\n\n\n\n\n\n\nFigura 4.2: Modelo digital del terreno (MDT) de Suiza. Se ha añadido efecto de sombreado para interpretar mejor el relieve de cada zona. Fuente: https://github.com/dominicroye/Taller_Carto_RqueR_2024.",
    "crumbs": [
      "Visualización avanzada",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualización avanzada</span>"
    ]
  },
  {
    "objectID": "05-mapas-interactivos.html",
    "href": "05-mapas-interactivos.html",
    "title": "5  Mapas interactivos",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, D. E. (1984). Literate Programming. Comput. J., 27(2), 97-111. https://doi.org/10.1093/comjnl/27.2.97",
    "crumbs": [
      "Visualización avanzada",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Mapas interactivos</span>"
    ]
  },
  {
    "objectID": "06-dashboards.html",
    "href": "06-dashboards.html",
    "title": "6  Dashboards",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, D. E. (1984). Literate Programming. Comput. J., 27(2), 97-111. https://doi.org/10.1093/comjnl/27.2.97",
    "crumbs": [
      "Visualización avanzada",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dashboards</span>"
    ]
  },
  {
    "objectID": "07-casos-estudio.html",
    "href": "07-casos-estudio.html",
    "title": "7  Casos de estudio",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, D. E. (1984). Literate Programming. Comput. J., 27(2), 97-111. https://doi.org/10.1093/comjnl/27.2.97",
    "crumbs": [
      "Aplicaciones",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Casos de estudio</span>"
    ]
  },
  {
    "objectID": "08-add-resources.html",
    "href": "08-add-resources.html",
    "title": "8  Recursos adicionales",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, D. E. (1984). Literate Programming. Comput. J., 27(2), 97-111. https://doi.org/10.1093/comjnl/27.2.97",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Recursos adicionales</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referencias",
    "section": "",
    "text": "Cressie, N. A. C. (1993). Statistics for spatial data. Revised\nedition. Wiley. https://doi.org/10.1002/9781119115151\n\n\nFahrmeir, L., Kneib, T., Lang, S., & Marx, B. D. (2022).\nRegression: Models, Methods and\nApplicatons (2nd ed.). Springer-Verlag GmbH. https://doi.org/10.1007/978-3-662-63882-8\n\n\nHolland, J. M., Perry, J. N., & Winder, L. (1999). The within-field\nspatial and temporal distribution of arthropods within winter wheat.\nBulletin of Entomological Research, 89, 499–513. https://doi.org/10.1017/S0007485399000656\n\n\nIhaka, R., & Gentleman, R. (1996). R: A language for data analysis\nand graphics. Journal of Computational and Graphical\nStatistics, 5(3), 299–314.\n\n\nKnuth, D. E. (1984). Literate programming. Comput. J.,\n27(2), 97–111. https://doi.org/10.1093/comjnl/27.2.97\n\n\nLovelace, R., Nowosad, J., & Muenchow, J. (2019). Geocomputation\nwith r. Chapman; Hall/CRC.\n\n\nR Core Team. (2025). R: A language and environment for statistical\ncomputing. R Foundation for Statistical Computing. https://www.R-project.org/\n\n\nVenables, W. N., & Ripley, B. D. (2002). Modern applied\nstatistics with s. Springer.\n\n\nWright, K. (2024). agridat: Agricultural\nDatasets. https://CRAN.R-project.org/package=agridat",
    "crumbs": [
      "Referencias"
    ]
  },
  {
    "objectID": "A-command-ref.html",
    "href": "A-command-ref.html",
    "title": "Apéndice A — Referencia de comandos",
    "section": "",
    "text": "A.1 Paquete ggplot2",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Referencia de comandos</span>"
    ]
  },
  {
    "objectID": "A-command-ref.html#paquete-ggplot2",
    "href": "A-command-ref.html#paquete-ggplot2",
    "title": "Apéndice A — Referencia de comandos",
    "section": "",
    "text": "Índice de funciones del paquete ggplot2: https://ggplot2.tidyverse.org/reference/.\nData visualization with ggplot2 cheat sheet: https://rstudio.github.io/cheatsheets/html/data-visualization.html.\nManual oficial de ggplot2: https://ggplot2-book.org (3ª ed. en progreso).",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Referencia de comandos</span>"
    ]
  },
  {
    "objectID": "A-command-ref.html#datos-espaciales",
    "href": "A-command-ref.html#datos-espaciales",
    "title": "Apéndice A — Referencia de comandos",
    "section": "A.2 Datos espaciales",
    "text": "A.2 Datos espaciales\n\nÍndice de funciones del paquete sf: https://r-spatial.github.io/sf/reference/index.html.\nÍndice de funciones del paquete terra: https://rspatial.github.io/terra/reference/index.html.\nSpatial Data Science with Applications in R (paquete sf): https://r-spatial.org/book/.\nGeocomputation with R (paquete terra): https://r.geocompx.org/.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Referencia de comandos</span>"
    ]
  },
  {
    "objectID": "B-packages.html",
    "href": "B-packages.html",
    "title": "Apéndice B — Paquetes R y atribuciones",
    "section": "",
    "text": "B.1 Paquetes R\nPara ejecutar los ejemplos incluidos en este taller, se necesita tener instalado R y una IDE de desarrollo para este lenguaje, como por ejemplo RStudio o Microsoft VS Code.\nAdemás, es necesario instalar los paquete descritos en la Tabla B.1.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Paquetes R y atribuciones</span>"
    ]
  },
  {
    "objectID": "B-packages.html#sec-pkg-requirements",
    "href": "B-packages.html#sec-pkg-requirements",
    "title": "Apéndice B — Paquetes R y atribuciones",
    "section": "",
    "text": "Tabla B.1: Listado de paquetes R utilizados en los ejemplos de este taller.\n\n\n\n\n\n\n\n\n\nPaquete\nDescripción\n\n\n\n\nggplot2\nPaquete principal de visualización de datos en el Tidyverse\n\n\ntidyverse\nMetapaquete que instala las herramientas principales del Tidyverse\n\n\nagridat\nConjunto de datos sobre experimentos deagricultura, incluyendo cultivos de campo, cultivos arbóreos o estudios con animales, entre otros\n\n\nHmisc\nFunciones de utilidad desarrolladas por Frank E. Harrell\n\n\nggthemes\nTemas adicionales para personalizar gráficos con ggplot2\n\n\nggstatsplot\nCreación de gráficas preapradas para publicaciones científicas\n\n\npatchwork\nComposición sencilla de varios gráficos con ggplot2 en la misma imagen\n\n\nGGally\nHerramientas adicionales que extienden la funcionalidad de ggplot2\n\n\nggpubr\nCreación de gráficas de calidad para publicación científica\n\n\nggfortify\nHerramientas de visualización para diagnóstico de modelos. Cuidado: puede tener interacciones problemáticas con otros paquetes\n\n\nfaraway\nFunciones y datos para los libros publicados por Julian J. Faraway\n\n\ntsibble\nSoporte para datos de series temporales compatible con el Tidyverse\n\n\nfeasts\nFunciones adicionales para extracción de features y estadísticas en series temporales\n\n\nclimaemet\nConector para obtención de datos de la API pública de AEMET\n\n\nsf\nSoporte para manipulación y representación de objetos representados con el estándar simple features\n\n\nmapview\nCreación de gráficos espaciales intereactivos en R",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Paquetes R y atribuciones</span>"
    ]
  },
  {
    "objectID": "B-packages.html#atribución-de-imágenes-e-iconos",
    "href": "B-packages.html#atribución-de-imágenes-e-iconos",
    "title": "Apéndice B — Paquetes R y atribuciones",
    "section": "B.2 Atribución de imágenes e iconos",
    "text": "B.2 Atribución de imágenes e iconos\nTodas las imágenes utilizadas de fuentes externas reciben atribución junto a su aparición en los contenidos de este taller.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Paquetes R y atribuciones</span>"
    ]
  }
]