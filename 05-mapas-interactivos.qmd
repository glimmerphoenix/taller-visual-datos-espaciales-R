# Mapas interactivos

Existen un gran número de herramientas en R para efectura representaciones de mapas. Por
ejemplo, los mapas de coropletas pueden generarse tanto en versión estática (@fig-choropleth-map) como interactiva (@fig-choropleth-leaflet), utilizando la biblioteca JavaScript
[Leaflet](https://leafletjs.com/).

El paquete {leaflet}`r emo::ji("package")` [@R-leaflet] es un interfaz a esta librería que nos permite aprovechar todas las capacidades de R para realizar estos mapas. Los mapas se generan en formato HTML que puede ser publicado en archivos autocontenidos que se abren en el navegador a través de RMarkdown, en servidores web convencionales o aplicaciones Shiny. Al generar documentos estáticos, como Word o PDF, en el documento se mostrará una imagen estática del mapa por defecto.

```{r}
#| label: fig-choropleth-map
#| fig-cap: "Mapa de coropletas clásico (estático) que muestra nacimientos en 1974 en los condados del estado de Carolina del Norte (EE.UU.). Fuente: <https://r-spatial.org/book/01-hello.html>."
#| message: false

library(tidyverse)
library(sf)
system.file("gpkg/nc.gpkg", package="sf") |>
    read_sf() -> nc
nc.32119 <- st_transform(nc, 'EPSG:32119')
nc.32119 |>
    select(BIR74) |>
    plot(graticule = TRUE, axes = TRUE)
```

```{r}
#| label: fig-choropleth-leaflet
#| fig-cap: "Mapa de coropletas interactivo usando Leaflet. Fuente: <https://r-spatial.org/book/01-hello.html>."

library(mapview) |> suppressPackageStartupMessages()
mapviewOptions(fgb = FALSE)
nc.32119 |> mapview(zcol = "BIR74", legend = TRUE, col.regions = sf.colors)
```

En este capítulo también se incluyen contenidos y ejemplos desarrollados por nuestro compañero del DSLAB
Emilio López Cano.

### Paquetes necesarios

Para ejecutar todos los ejemplos de este documento necesitas los siguientes paquetes R. 


```{r pkg, message=FALSE}
# Paquetes de funcionalidades
library(tidyverse)
library(kableExtra)
library(htmltools)

# Paquetes de mapas
library(leaflet)
library(maps)
library(sp)
library(sf)
# library(simplevis) not in CRAN anymore
library(mapSpain)
library(terra)
library(raster)
library(mapview)
```

### Introducción a Leaflet para R

Leaflet se ha integrado en R gracias al paquete {htmlwidgets} [@R-htmlwidgets]. Estos _widgets_ son librerías JavaScript muy completas para visualizaciones y presentación de datos. Además de Leaflet, existen muchos otros paquetes para gráficos interactivos similares, como Plotly o DataTable (ver [galería](http://www.htmlwidgets.org/showcase_leaflet.html)).

#### Características

* Zoom y desplazamiento interactivo.
* Composición de mapas utilizando combinaciones arbitrarias de:
  + Mapas (calles, recintos, ...).
  + Marcadores (puntos).
  + Polígonos.
  + Líneas.
  + Popups.
  + GeoJSON.

* Creación de mapas directamente desde la consola de R o RStudio.
* Inclusión de mapas en documentos knitr/R Markdown [@R-knitr] y aplicaciones Shiny [@R-shiny].
* Fácil representación de objetos espaciales del paquete {sf} [@R-sf], o _data frames_ con columnas de latitud/longitud.
* Utilizar los límites del mapa y los eventos del ratón para controlar la lógica de Shiny.
* Visualización de mapas en proyecciones mercator no esféricas.
* Aumentar las características de los mapas utilizando los plugins de [leaflet plugin repository](https://leafletjs.com/plugins).


#### Instalación

El paquete se instala de forma convencional, desde CRAN o desde github:

```{r, eval=FALSE}
install.packages("leaflet")
# devtools::install_github("rstudio/leaflet")
```

Una vez instalado, se puede usar en scripts, documentos R Markdown o aplicaciones Shiny
cargando el paquete:

```{r, eval=FALSE}
library(leaflet)
```

#### Uso básico

Para crear un mapa Leaflet se siguen los siguientes pasos:

1. Crear un widget de mapa llamando a `leaflet()`.
2. Añadir capas (es decir, características) al mapa utilizando funciones de capa
(por ejemplo,` addTiles`, `addMarkers`, `addPolygons`) para modificar el widget de mapa.
3. Repetir el paso 2 como se quiera.
4. Imprimir el widget de mapa para mostrarlo.

Este es un ejemplo básico:

```{r}
m <- leaflet() |> 
  addTiles() |>   # Añade las capas por defecto de OpenStreetMap
  addMarkers(lng = -3.87841, lat = 40.33608, popup="The Data Science Laboratory")
m  # Imprimir el mapa
```

#### El widget de mapa

La función `leaflet()` devuelve un _widget_ de mapa Leaflet, que almacena una lista de objetos que pueden ser modificados o actualizados posteriormente. La mayoría de las funciones de este paquete tienen como primer argumento un mapa, lo que facilita el uso del operador _pipe_ `|>`, como has visto en el ejemplo de la Introducción.

#### Inicialización de opciones

El widget de mapa puede ser inicializado con ciertos parámetros. Esto se consigue pasando valores con el argumento `options` como se muestra a continuación.

```{r, eval=FALSE}
leaflet(options = leafletOptions(minZoom = 0, maxZoom = 18))
```

A `leafletOptions()` se le puede pasar cualquier opción descrita en el documento de [referencia de leaflet](https://leafletjs.com/reference.html#map-option). Usando `leafletOptions()`, se puede establecer un CRS personalizado y hacer que el mapa se muestre en una proyección mercator no esférica.

#### Métodos de mapa

Se pueden manipular los atributos del widget de mapa utilizando una serie de métodos. Consulta la página de ayuda `?setView` para más detalles.

* `setView()` establece el centro de la vista del mapa y el nivel de zoom;
* `fitBounds()` ajusta la vista en el rectángulo [lng1, lat1] - [lng2, lat2];
* `clearBounds()` borra el límite, de modo que la vista será determinada automáticamente por el rango de datos de latitud/longitud en las capas del mapa si se proporcionan;

#### El objeto de datos

Tanto `leaflet()` como las funciones de las capas de mapa tienen un parámetro de datos opcional que está diseñado para recibir datos espaciales en una de las siguientes formas:

* De R base:
  + matriz lng/lat
  + data.frame con columnas lng/lat
* Desde el paquete {sp}:
  + SpatialPoints[DataFrame]
  + Línea/Líneas
  + SpatialLines[DataFrame]
  + Polígono/Polígonos
  + SpatialPolygons[DataFrame]
* Del paquete `maps`:
  + el data.frame devuelto por `map()`
* Desde el paquete `sf`: igual de fácil que `sp`

El argumento `data` se utiliza para obtener los datos espaciales para las funciones que los necesitan; por ejemplo, si data es un objeto `SpatialPolygonsDataFrame`, al llamar a `addPolygons` en ese widget de mapa se sabrá que hay que añadir los polígonos de ese `SpatialPolygonsDataFrame`.

Es sencillo derivar estas variables de los objetos `sp` ya que siempre representan los datos espaciales de la misma manera. Por otro lado, para una matriz o data.frame normal, cualquier columna numérica podría contener datos espaciales. Por lo tanto, se intenta averiguar basándose en los nombres de las columnas:

* la variable de latitud se adivina buscando las columnas denominadas lat o latitude (sin distinguir entre mayúsculas y minúsculas)
* la variable de longitud se adivina buscando lng, long o longitude

Siempre se pueden identificar explícitamente las columnas de latitud/longitud proporcionando los argumentos lng y lat a la función de capa.

Por ejemplo, a continuación no especificamos los valores para los argumentos lat y lng en `addCircles()`, pero las columnas Lat y Long del data.frame `df` se utilizarán automáticamente:

```{r, eval = FALSE}
df  <-  data.frame(Lat = 1:10, Long = rnorm(10))
leaflet(df)  |>  addCircles()
```

También puedes especificar explícitamente las columnas Lat y Long (después se explica la sintaxis ~):

```{r, eval=FALSE}
leaflet(df) |> addCircles(lng = ~Long, lat = ~Lat)
```

Una capa de mapa puede utilizar un objeto de datos diferente para no usar los datos proporcionados en leaflet(). Podemos reescribir el ejemplo anterior como

```{r, eval=FALSE}
leaflet() |> addCircles(data = df)
leaflet() |> addCircles(data = df, lat = ~ Lat, lng = ~ Long)
```

A continuación se muestran ejemplos de uso de `sp` y `maps`.

```{r}
Sr1 <- Polygon(cbind(c(2, 4, 4, 1, 2), c(2, 3, 5, 4, 2)))
Sr2 <- Polygon(cbind(c(5, 4, 2, 5), c(2, 3, 2, 2)))
Sr3 <- Polygon(cbind(c(4, 4, 5, 10, 4), c(5, 3, 2, 5, 5)))
Sr4 <- Polygon(cbind(c(5, 6, 6, 5, 5), c(4, 4, 3, 3, 4)), hole = TRUE)
Srs1 <- Polygons(list(Sr1), "s1")
Srs2 <- Polygons(list(Sr2), "s2")
Srs3 <- Polygons(list(Sr4, Sr3), "s3/4")
SpP <- SpatialPolygons(list(Srs1, Srs2, Srs3), 1:3)
leaflet(height = "300px") |> addPolygons(data = SpP)
```


```{r}
mapStates = map("state", fill = TRUE, plot = FALSE)
leaflet(data = mapStates) |> addTiles() |>
  addPolygons(fillColor = topo.colors(10, alpha = NULL), stroke = FALSE)
```

#### La interfaz de fórmula

Los argumentos de todas las funciones de capa pueden tomar objetos R normales, como un vector numérico para el argumento lat, o un vector de caracteres de colores para el argumento color. También pueden tomar una fórmula unilateral, en cuyo caso la fórmula se evaluará utilizando el argumento `data` como `environment`. Por ejemplo, `~ x` significa la variable `x` en el objeto `data`, y se pueden escribir expresiones arbitrarias en el lado derecho, por ejemplo, `~ sqrt(x + 1)`.

```{r, eval=FALSE}
m  <-  leaflet() |> addTiles()
df <- data.frame(
  lat = rnorm(100),
  lng = rnorm(100),
  size = runif(100, 5, 20),
  color = sample(colors(), 100)
)
m <- leaflet(df) |> addTiles()
m |>  addCircleMarkers(radius = ~size, color = ~color, fill = FALSE)
m |>  addCircleMarkers(radius = runif(100, 4, 10), color = c('red'))
```

### Uso de mapas base

Leaflet admite el uso de mapas base mediante `map tiles` (mosaicos, aunque la traducción no es fácil), popularizados por Google Maps y utilizados ahora por casi todos los mapas web interactivos.

#### _Tiles_ por defecto (OpenStreetMap)

La forma más sencilla de añadir mosaicos es llamando a `addTiles()` sin argumentos; por defecto, se utilizan los mosaicos de OpenStreetMap.

```{r}
m <- leaflet() |> setView(lng =  -1.8548, lat = 38.9812, zoom = 12)
m |> addTiles()
```

#### _Tiles_ de terceros

Alternativamente, se pueden añadir muchos mapas base gratuitos de terceros usando la función `addProviderTiles()`, que se implementa usando el plugin leaflet-providers. Consulta [aquí](http://leaflet-extras.github.io/leaflet-providers/preview/index.html) el conjunto completo.

`leaflet` también proporciona una lista con nombre de todos los proveedores de mapas que soporta el plugin. Esto le permite utilizar la función de autocompletado de RStudio: simplemente escribe providers$ y elige una de las opciones. 

```{r add-provider-tiles}
m |> addProviderTiles(providers$CartoDB.Positron)
m |> addProviderTiles(providers$Esri.NatGeoWorldMap)
```

Algunos proveedores de conjuntos de _tiles_ requieren registro; consulte la página del proyecto para obtener más información. Puedes pasar tokens/claves de acceso, y otras opciones, al proveedor de azulejos rellenando el argumento opciones con la función providerTileOptions().

#### Plantilla de URL de _tiles_ personalizada

Si tienes una plantilla de URL de _map tiles_ personalizada para usar, puedes proporcionarla como argumento a addTiles().

#### WMS _tiles_

Puedes utilizar `addWMSTiles()` para añadir _tiles_ WMS (Web Map Service). El siguiente mapa muestra la reflectividad base (una medida de la intensidad de las precipitaciones que se producen) utilizando el WMS de la [Iowa Environmental Mesonet](https://mesonet.agron.iastate.edu/):    

```{r add-wms-tiles}
leaflet() |> addTiles() |> setView(-93.65, 42.0285, zoom = 4) |>
  addWMSTiles(
    "http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi",
    layers = "nexrad-n0r-900913",
    options = WMSTileOptions(format = "image/png", transparent = TRUE),
    attribution = "Weather data © 2012 IEM Nexrad"
  )
```

#### Combinar capas de _tiles_

Se puede usar más de un mapa base en un mapa; se pueden apilar añadiendo múltiples capas de _tiles_. Esto generalmente sólo tiene sentido si las capas superiores consisten en _tiles_ semitransparentes, o tienen una opacidad ajustada a través del argumento de opciones.

```{r add-provider-tiles-multi}
m |> addProviderTiles(providers$MtbMap) |>
  addProviderTiles(providers$Stadia.StamenTonerLines,
                   options = providerTileOptions(opacity = 0.35)) |>
  addProviderTiles(providers$Stadia.StamenTonerLabels)
```

## Representación de datos puntuales

### Datos de ejemplo

En este punto vamos a cargar los datos de ejemplo que vamos a utilizar para representar en el mapa. No siempre los datos están tan bien preparados como en los ejemplos "bonitos" de los paquetes. En este caso hemos descargado un conjunto de datos abiertos del Ayuntamiento de Madrid sobre las estaciones de medición de contaminación.

```{r, message=FALSE, warning=FALSE}
estaciones <- read_delim("https://lcano.com/data/geo/informacion_estaciones_red_calidad_aire.csv",
                         delim = ";", 
                         escape_double = FALSE, 
                         locale = locale(decimal_mark = ".",
                                         grouping_mark = ",", 
                                         encoding = "ISO-8859-1"),
                         trim_ws = TRUE)
magnitudes <- read.csv2("https://lcano.com/data/geo/magnitudes.csv")

datosori <- read_delim("https://lcano.com/data/geo/datos202110.csv", 
                       delim = ";", 
                       escape_double = FALSE, 
                       locale = locale(decimal_mark = ",", 
                                       grouping_mark = ".", 
                                       encoding = "ISO-8859-1"), 
                       trim_ws = TRUE)

datos <- datosori |> 
  inner_join(magnitudes |> dplyr::select(id, Abreviatura),
             by = c("MAGNITUD" = "id")) |> 
  dplyr::select(ESTACION, MAGNITUD = Abreviatura, ANO, MES, starts_with("D")) |> 
  pivot_longer(cols = starts_with("D"),
               names_to = "DIA",
               values_to = "Valor") |> 
  mutate(DIA = str_sub(DIA, 2),
         Valor = as.numeric(Valor)) |> 
  pivot_wider(names_from = "MAGNITUD",
              values_from = "Valor") |> 
  inner_join(estaciones |> dplyr::select(CODIGO_CORTO, LONGITUD, LATITUD),
             by = c("ESTACION" = "CODIGO_CORTO"))

```

Ahora tenemos un data.frame con los datos de las estaciones, incluidas las coordenadas, y otro con los datos de la contaminación, que además hemos unido.

```{r estaciones}
estaciones |> dplyr::select(CODIGO_CORTO, ESTACION, LONGITUD, LATITUD) |>  kbl(format = "markdown")
```


### Marcadores

Utilizamos marcadores para señalar **puntos** en el mapa. Las ubicaciones de los marcadores se expresan en coordenadas de latitud y longitud, y pueden aparecer como iconos o como círculos.

#### Fuentes de datos

Los datos de puntos para los marcadores pueden proceder de diversas fuentes:

* Objetos SpatialPoints o SpatialPointsDataFrame (del paquete {sp})
* Objetos POINT, sfc_POINT y sf (del paquete {sf}); sólo se considerarán las dimensiones X e Y
* Matrices numéricas de dos columnas (la primera columna es la longitud y la segunda la latitud)
* data.frame con columnas de latitud y longitud. Puede indicar explícitamente a la función de marcadores qué columnas contienen los datos de coordenadas (por ejemplo, addMarkers(lng = ~Longitud, lat = ~Latitud)), o dejar que la función busque las columnas denominadas lat/latitud y lon/lng/longitud (sin distinguir mayúsculas y minúsculas).
* Simplemente proporcione vectores numéricos como argumentos lng y lat

Tenga en cuenta que los objetos MULTIPOINT de sf no son compatibles en este momento.

#### Marcadores de icono

Los iconos se añaden mediante las funciones addMarkers o addAwesomeMarkers. Su apariencia por defecto es la de un marcador de posición. Como en la mayoría de las funciones de capa, el argumento popup puede utilizarse para añadir un mensaje que se mostrará al hacer clic, y la opción label puede utilizarse para mostrar una etiqueta de texto, ya sea al pasar por encima o de forma estática.

```{r}
estaciones |> 
  leaflet()  |> 
  addTiles() |> 
  addMarkers(~LONGITUD, ~LATITUD, 
             popup = ~as.character(ESTACION),
             label = ~as.character(CODIGO_CORTO))
```

#### Personalización de los iconos de los marcadores

Se pueden proporcionar marcadores personalizados de varias maneras, dependiendo del escenario. Para cada una de estas formas, el icono puede proporcionarse como una URL o como una ruta de archivo.

Para el caso simple de aplicar un único icono a un conjunto de marcadores, utiliza makeIcon().

```{r}
myIcon <- makeIcon(
  iconUrl = "https://lcano.com/c/visr/img/emilio.png",
  iconWidth = 20, iconHeight = 20,
  iconAnchorX = 20, iconAnchorY = 20,
  shadowUrl = "https://lcano.com/c/visr/img/emilio.png",
  shadowWidth = 20, shadowHeight = 20,
  shadowAnchorX = 4, shadowAnchorY = 4
)

leaflet(data = estaciones) |> addTiles() |>
  addMarkers(~LONGITUD, ~LATITUD, icon = myIcon)
```

Si tienes varios iconos para aplicar que varían sólo por un par de parámetros (es decir, comparten el mismo tamaño y puntos de anclaje pero tienen diferentes URLs), utiliza la función icons(). icons() se comporta de forma similar a data.frame(), en el sentido de que cualquier argumento que sea más corto que el número de marcadores se reciclará para que quepa.

```{r}
ourIcons <- icons(
  iconUrl = ifelse(estaciones$ALTITUD < 650,
                   "https://lcano.com/c/visr/img/emilio.png",
                   "https://lcano.com/c/visr/img/felipe.jpeg"
  ),
  iconWidth = 20, iconHeight = 20,
  iconAnchorX = 20, iconAnchorY = 20,
  shadowUrl = "https://lcano.com/c/visr/img/emilio.png",
  shadowWidth = 20, shadowHeight = 20,
  shadowAnchorX = 4, shadowAnchorY = 4
)

leaflet(data = estaciones) |> addTiles() |>
  addMarkers(~LONGITUD, ~LATITUD, icon = ourIcons)
```

Por último, si tienes un conjunto de iconos que varían en varios parámetros, puede ser más conveniente utilizar la función iconList(). Te permite crear una lista de iconos (con o sin nombre) de makeIcon(), y seleccionar de esa lista por posición o nombre.


```{r, include=FALSE}
# Make a list of icons. We'll index into it based on name.
oceanIcons <- iconList(
  ship = makeIcon("ferry-18.png", "ferry-18@2x.png", 18, 18),
  pirate = makeIcon("danger-24.png", "danger-24@2x.png", 24, 24)
)

# Some fake data
df <- sp::SpatialPointsDataFrame(
  cbind(
    (runif(20) - .5) * 10 - 90.620130,  # lng
    (runif(20) - .5) * 3.8 + 25.638077  # lat
  ),
  data.frame(type = factor(
    ifelse(runif(20) > 0.75, "pirate", "ship"),
    c("ship", "pirate")
  ))
)

leaflet(df) |> addTiles() |>
  # Select from oceanIcons based on df$type
  addMarkers(icon = ~oceanIcons[type])
```

#### Iconos _Awesome_

Leaflet soporta aún más marcadores personalizables utilizando el plugin de leaflet awesome markers.

La función addAwesomeMarkers() es similar a la función addMarkers() pero además permite especificar colores personalizados para los marcadores así como iconos de las bibliotecas de iconos Font Awesome, Bootstrap Glyphicons e Ion.

De forma similar a las funciones makeIcon, icons e iconList descritas anteriormente, tienes las funciones makeAwesomeIcon, awesomeIcons y awesomeIconList, que te permiten añadir iconos _awesome_

```{r}
# first 20 quakes

getColor <- function(estaciones) {
  sapply(estaciones$ALTITUD, function(al) {
    if(al <= 625) {
      "green"
    } else if(al <= 700) {
      "orange"
    } else {
      "red"
    } })
}

icons <- awesomeIcons(
  icon = 'ios-close',
  iconColor = 'black',
  library = 'ion',
  markerColor = getColor(estaciones)
)

leaflet(estaciones) |> addTiles() |>
  addAwesomeMarkers(~LONGITUD, ~LATITUD, icon=icons, label=~as.character(ALTITUD))
```

El argumento `library` debe ser uno de los siguientes: 'ion', 'fa' o 'glyphicon'. El argumento `icon` debe ser el nombre de cualquier icono válido soportado por la biblioteca respectiva (sin el prefijo del nombre de la biblioteca).

#### Grupos de marcadores

Cuando hay un gran número de marcadores en un mapa, puede agruparlos utilizando el complemento Leaflet.markercluster. Para activar este complemento, puedes proporcionar una lista de opciones al argumento clusterOptions, por ejemplo

```{r}
leaflet(estaciones) |> addTiles() |> addMarkers(~LONGITUD, ~LATITUD,
                                                  clusterOptions = markerClusterOptions()
)
```

Usando el argumento freezeAtZoom de la función markerClusterOptions() puede establecerse que el cluster se congele a un nivel de zoom específico. Por ejemplo, markerClusterOptions(freezeAtZoom = 5) congelará el cluster en el nivel de zoom 5, independientemente del nivel de zoom real del usuario.

#### Marcadores de círculo

Los marcadores de círculo son muy parecidos a los círculos normales (véase Líneas y formas), excepto que su radio en píxeles en pantalla permanece constante independientemente del nivel de zoom.

Puede utilizar su apariencia por defecto:

```{r}
leaflet(estaciones) |> addTiles() |> addCircleMarkers(~LONGITUD, ~LATITUD)
```

O personalizar elementos:

```{r}
pal <- colorFactor(c("navy", "red"), domain = c("ship", "pirate"))
leaflet(estaciones) |> 
  addTiles() |> 
  addCircleMarkers(~LONGITUD, ~LATITUD,
                   radius = ~ifelse(COD_TIPO == "UT", 6, 10),
                   color = ~pal(COD_TIPO),
                   stroke = FALSE, fillOpacity = 0.5)
```


### Popus y etiquetas

#### Popups (ventanas emergentes)

Los popups son pequeñas cajas que contienen HTML arbitrario, que apuntan a un punto específico del mapa.

Utilice la función addPopups() para añadir un popup independiente al mapa.

```{r}
content <- paste(sep = "<br/>",
  "<b><a href='http://www.datasciencelab.es'>DSLAB</a></b>",
  "Data Science Laboratory",
  "Móstoles, Madrid"
)

leaflet() |> addTiles() |>
  addPopups(-3.87841, 40.33608, content,
    options = popupOptions(closeButton = FALSE)
  )
```

Un uso común de las ventanas emergentes es hacerlas aparecer cuando se hace clic en los marcadores o en las formas. Las funciones de marcadores y formas en el paquete de Leaflet toman un argumento de ventana emergente, donde se puede pasar HTML para adjuntar fácilmente una ventana emergente simple.

```{r}
estaciones |> 
  leaflet()  |> 
  addTiles() |> 
  addMarkers(~LONGITUD, ~LATITUD, 
             popup = ~as.character(ESTACION))
```

En el ejemplo anterior, se utilizó `htmltools::htmlEscape` para sanear cualquier carácter del nombre que pudiera ser interpretado como HTML. Aunque no era necesario para este ejemplo (ya que los nombres de los restaurantes no contenían marcas HTML), hacerlo es importante en cualquier situación en la que los datos puedan provenir de un archivo o base de datos, o del usuario.

Además de los marcadores, también se pueden añadir ventanas emergentes en formas como líneas, círculos y otros polígonos.

#### Etiquetas

Una etiqueta es un contenido textual o HTML que puede adjuntarse a los marcadores y formas para que se muestren siempre o al pasar el ratón por encima. A diferencia de las ventanas emergentes, no es necesario hacer clic en un marcador o polígono para que se muestre la etiqueta.

```{r}
estaciones |> 
  leaflet()  |> 
  addTiles() |> 
  addMarkers(~LONGITUD, ~LATITUD, 
             label = ~htmlEscape(DIRECCION))
```

#### Personalización de las etiquetas de los marcadores

Puede personalizar las etiquetas de los marcadores utilizando el argumento `labelOptions` de la función `addMarkers()`. El argumento `labelOptions` puede rellenarse con la función `labelOptions()`. Si `noHide` es falso (el valor predeterminado), la etiqueta se muestra sólo cuando se pasa el ratón por encima del marcador; si `noHide` se establece como verdadero, la etiqueta se muestra siempre.

```{r, eval=FALSE, include=FALSE}
# Change Text Size and text Only and also a custom CSS
leaflet() |> addTiles() |> setView(-118.456554, 34.09, 13) |>
  addMarkers(
    lng = -118.456554, lat = 34.105,
    label = "Default Label",
    labelOptions = labelOptions(noHide = T)) |>
  addMarkers(
    lng = -118.456554, lat = 34.095,
    label = "Label w/o surrounding box",
    labelOptions = labelOptions(noHide = T, textOnly = TRUE)) |>
  addMarkers(
    lng = -118.456554, lat = 34.085,
    label = "label w/ textsize 15px",
    labelOptions = labelOptions(noHide = T, textsize = "15px")) |>
  addMarkers(
    lng = -118.456554, lat = 34.075,
    label = "Label w/ custom CSS style",
    labelOptions = labelOptions(noHide = T, direction = "bottom",
      style = list(
        "color" = "red",
        "font-family" = "serif",
        "font-style" = "italic",
        "box-shadow" = "3px 3px rgba(0,0,0,0.25)",
        "font-size" = "12px",
        "border-color" = "rgba(0,0,0,0.5)"
      )))
```

#### Etiquetas sin marcadores

Puede crear etiquetas sin los marcadores que las acompañan utilizando la función `addLabelOnlyMarkers()`.

### Datos puntuales en formato sf en {leaflet}

Para completar este apartado, vamos a comprobar cómo los datos en formato sf también se pueden representar fácilmente con leaflet. Si la geometría son puntos, automáticamente toma las coordenadas sin más. El siguiente ejemplo representa las estaciones de tren de Mallorca usando los datos en formato `sf` del paquete {mapSpain}.


```{r, warning=FALSE}
estaciones_tren <- esp_get_railway(spatialtype = "point")
estaciones_tren |> 
  filter(str_sub(id_ine, 1, 2) == "07") |>
  leaflet() |> 
  addTiles() |> 
  addMarkers()
```


## Líneas y formas

Leaflet facilita la lectura de líneas y formas espaciales de R y las añade a los mapas.


### Polígonos y polilíneas

Los datos de líneas y polígonos pueden provenir de una variedad de fuentes:

* SpatialPolygons, SpatialPolygonsDataFrame, Polygons y objetos Polygon (del paquete {sp})
* SpatialLines, SpatialLinesDataFrame, Lines y objetos Line (del paquete {sp})
* Objetos MULTIPOLYGON, POLYGON, MULTILINESTRING y LINESTRING (del paquete {sf})
* objetos map (de la función `map()` del paquete {maps}); utilice `map(fill = TRUE)` para los polígonos, FALSE para las polilíneas
* Matriz numérica de dos columnas; la primera columna es la longitud y la segunda la latitud. Los polígonos están separados por filas de (NA, NA). No es posible representar polígonos múltiples ni polígonos con agujeros utilizando este método; utilice SpatialPolygons en su lugar.

Vamos a representar las vías de tren en España que sean Ferrocarriles autonómicos. Al igual que añadíamos datos puntuales, podemos añadir formar lineales con `addPolylines()`

```{r, warning=FALSE}
vias_tren <- esp_get_railway(spatialtype = "line")
vias_tren |> 
  filter(tipo == "Ferrocarriles autonómicos") |>
  leaflet() |> 
  addTiles() |> 
  addPolylines()
```


En cuanto a los polígonos, tenemos la función `addPolygons()`. De nuevo, con objetos de clase `sf` es totalmente automático. 

```{r}
madridbase <- esp_munic.sf |> 
  filter(ine.prov.name == "Madrid") |> 
  leaflet() |> 
  addTiles() 
madridbase|> 
  addPolygons()
```

Las opciones por defecto pueden no ser las adecuadas. Vamos a darle algo de formato y a añadir información adicional. Se pueden añadir _labels_ y _popups_ como en los datos puntuales.

```{r}
madridbase |> 
  addPolygons(weight = 1, 
              color = "orange",
              fillOpacity = 0.25,
              highlightOptions = highlightOptions(color = "black",
                                                  weight = 2,
                                                  bringToFront = TRUE),
              label = ~name,
              popup = ~paste0("Código municipio: ", cmun)
              )
  
```

## Representación de datos de área

### Datos de polígonos

Cuando tenemos datos de polígonos, la representación más sencilla de datos de área es coloreando los polígonos de acuerdo al valor de la variable que queremos representar. Vamos a usar los datos geográficos de los municipios de Madrid del paquete {mapSpain} y los vamos a unir a los datos de población del mismo paquete y a los datos del atlas de renta de los hogares^[https://www.ine.es/experimental/atlas/exp_atlas_tab.htm].

```{r}
renta <- readRDS(url("https://lcano.com/data/geo/MADRID.rds")) |> 
  filter(nchar(GEO_codigo) == 5)
madrid <- esp_munic.sf  |> 
  inner_join(pobmun19 |> 
               filter(provincia == "Madrid") |> 
               dplyr::select(cmun, pob19, men, women), 
             by = "cmun") |> 
  inner_join(renta, by = c("LAU_CODE" = "GEO_codigo")) 
```

### Colores

Leaflet tiene una serie de funciones `color*()` para crear funciones de paletas personalizadas de forma que se puedan mapear las variables a los colores.
Esencialmente, se llama a la función de color apropiada con 1) los colores que desea utilizar y 2) opcionalmente, el rango de entradas (es decir, el **dominio**) que se espera. La función de color devuelve una función de paleta a la que se le puede pasar un vector de valores de entrada, y devolverá un vector de colores en formato #RRGGBB(AA). Por ejemplo:

```{r}
pal <- colorNumeric(c("red", "green", "blue"), 1:10)
pal(c(1, 6, 9))
```

Las cuatro funciones de color tienen dos argumentos obligatorios, `palette` y `domain`.

El argumento `palette` especifica los colores a los que se asignan los datos. Este argumento puede tomar una de varias formas:

* El nombre de una paleta preestablecida del paquete RColorBrewer, por ejemplo "RdYlBu", "Accent" o "Greens".
* El nombre completo de una paleta viridis: "viridis", "magma", "inferno" o "plasma".
* Un vector de caracteres de colores RGB o con nombre, por ejemplo, `palette()`, `c("#000000", "#0000FF", "#FFFFFF")`, `topo.colors(10)`.
* Una función que recibe un único valor entre 0 y 1 y devuelve un color, por ejemplo: `colorRamp(c("#000000", "#FFFFFF"), interpolate="spline")`
* El argumento `domain` indica a la función de color el rango de valores de entrada. Aquí se puede pasar `NULL` para crear una función de paleta que no tenga un rango preestablecido; el rango se inferirá de los datos cada vez que invoque la función de paleta. Si se utiliza una función de paleta varias veces en diferentes datos, es importante proporcionar un valor no NULL para el dominio para que la escala entre los datos y los colores sea consistente.

#### Entrada continua, colores continuos: `colorNumeric`

Empecemos por mapear los valores de la población directamente a la paleta "Blues" de [Color Brewer 2](https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3). Utilizaremos la función `colorNumeric()` para crear una función de mapeo. La paleta "Blues" sólo contiene nueve colores, pero `colorNumeric()` interpola estos colores para que obtengamos una salida continua.

```{r}
pal <- colorNumeric(
  palette = "Blues",
  domain = madrid$pob19)
```

El parámetro `palette` es la lista ordenada de colores a la que se asignarán los colores. En este caso utilizamos una paleta Color Brewer, pero podríamos haber utilizado `c("white", "navy")` o `c("#FFFFFF", "#000080")` para un efecto similar. También puede pasar más de dos colores, para una paleta divergente, por ejemplo. Y para una máxima flexibilidad, puede incluso pasar una función que tome un valor numérico en el intervalo [0,1] y devuelva un color.


El segundo parámetro, `domain`, indica el conjunto de valores de entrada que estamos mapeando a estos colores. Para `colorNumeric`, se puede proporcionar un mínimo/máximo como en este ejemplo, o un conjunto de números sobre los que `colorNumeric()` puede llamar a `range()`.

El resultado es `pal()`, una función que puede aceptar vectores numéricos con valores en el rango `range(countries$gdp_md_est)` y devolver colores en formato "#RRGGBB".

```{r}
madrid |> 
  leaflet() |> 
  addTiles() |> 
  addPolygons(stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,
    color = ~pal(pob19))
```

Lo mismo podríamos hacer con las otras varibles, o combinación de estas. Por ejemplo, veamos el mapa según la proporción de mujeres. Tenemos que crear una función de paleta distinta.

```{r}
madrid <- madrid |> 
  mutate(propm = women/pob19, .before = "geometry") |> 
  mutate(npalabras = factor(str_count(name, " ") + 1), .before = "geometry")
pal <- colorNumeric(
  palette = "Blues",
  domain = madrid$propm)
madridbase2 <- madrid |> 
  leaflet() |> 
  addTiles() 
madridbase2 |> 
  addPolygons(stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,
    color = ~pal(propm))
```

#### Entrada continua, colores discretos (colorBin y colorQuantile)

La función `colorBin()` asigna los datos de entrada numéricos a un número fijo de colores de salida discretizando (dividiendo el dominio de entrada en varias clases según los valores).

Se pueden especificar los cortes exactos a utilizar, o el número deseado de intervalos. Téngase en cuenta que, en este último caso, si `pretty=TRUE` (el valor predeterminado) acabará con cortes redondeados, pero no necesariamente con el número de intervalos deseado.

```{r}
binpal <- colorBin("viridis", madrid$propm, 6, pretty = FALSE)
madridbase2 |> 
  addPolygons(stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,
    color = ~binpal(propm))
```

`colorQuantile()` asigna datos numéricos de entrada a un número fijo de colores de salida utilizando cuantiles (cortando el dominio de entrada en subconjuntos con igual número de observaciones). Vamos a usar ahora la variable de la renta.

```{r}
qpal <- colorQuantile("magma", madrid$Renta, n = 4)
madridbase2 |> 
  addPolygons(stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,
    color = ~qpal(Renta))
```

#### Colorear datos categóricos

Para datos categóricos, se utiliza la función `colorFactor()`. Si la paleta contiene el mismo número de elementos que niveles de factor, el mapeo será 1:1; en caso contrario, la paleta se interpolará para producir el número de colores deseado.

Se puede especificar el dominio de entrada pasando un factor o vector de caracteres a `domain`, o proporcionando niveles directamente usando el parámetro `levels` (en cuyo caso se ignorará el dominio). A modo de ejemplo, vamos a colorear de forma distinta los municipios según el número de palabras que tiene su nombre.

```{r}
factpal <- colorFactor(topo.colors(6), madrid$npalabras)

madridbase2 |> 
  addPolygons(stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,
    color = ~factpal(npalabras))
```

### Leyendas

Las mapas realizados en el apartado anterior carecen de sentido si no se conoce 
lo que significan los colores.

La función `addLegend()` añade una leyenda al mapa. La forma más sencilla de utilizar `addLegend()` es proporcionar `pal` (una función de paleta, como la generada a partir de `colorNumeric` o las otras) y valores, y dejar que calcule los colores y las etiquetas por sí mismo.

En la mayoría de los casos simplemente separaremos la función y el argumento que se pasa a `addPolygons(color=...)`, como en este ejemplo:

```{r}
pal <- colorNumeric(
  palette = "YlGnBu",
  domain = madrid$propm*100
)
madridbase2 |> 
  addPolygons(stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,
    color = ~pal(propm*100)
  ) |> 
  addLegend("bottomright", pal = pal, values = ~propm*100,
    title = "Proporción de mujeres",
    labFormat = labelFormat(suffix = "%"),
    opacity = 1
  )
```

La función `addLegend()` tiene en cuenta los diferentes tipos de funciones de paleta, y creará una representación por defecto apropiada para cada tipo. Por ejemplo, compara la leyenda creada para la paleta basada en `colorNumeric()` anterior con la paleta basada en `colorQuantile()` a continuación. Esta última muestra los rangos de probabilidad, con un _tooltip_ de rango de valores.

```{r}
qpal <- colorQuantile("RdYlBu", madrid$propm*100, n = 4)
madridbase2 %>%
  addPolygons(stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,
    color = ~qpal(madrid$propm*100)
  ) %>%
  addLegend(pal = qpal, values = ~madrid$propm*100, opacity = 1)
```

La función `addLegend()` tiene otros parámetros que  permiten personalizar la leyenda de varias maneras. En lugar de utilizar `pal` y valores, se pueden pasar explícitamente colores y etiquetas. Se puede cambiar el título y la opacidad del color.

También se puede personalizar convenientemente la apariencia de la etiqueta pasando `labFormat=labelFormat()`. La función `labelFormat()` tiene parámetros que personalizan el separador entre rangos, el número de dígitos a renderizar, y el prefijo/sufijo para cada etiqueta. Si las necesidades de formato de etiqueta van más allá de lo que `labelFormat()` puede proporcionar, también se puede utilizar una función personalizada como argumento de `labFormat()`; consulta la sección Details en `?addLegend` para obtener una descripción.


### Datos raster

Los objetos bidimensionales `RasterLayer` (del paquete {raster})  pueden convertirse en imágenes y añadirse a los mapas de Leaflet mediante la función `addRasterImage()`.

La función `addRasterImage()` trabaja proyectando el objeto `RasterLayer` a EPSG:3857 y codificando cada celda a un color RGBA, para producir una imagen PNG. Esa imagen se incrusta en el widget del mapa.

Es importante que el objeto `RasterLayer` esté etiquetado con un sistema de referencia de coordenadas adecuado. Muchos archivos raster contienen esta información, pero otros no. 

Si tenemos la imagen raster en la clase `SpatRaster` de {terra}, primero la convertimos a `RasterLayer` de {raster}.

```{r}
raster_filepath <- system.file("raster/srtm.tif", 
                               package = "spDataLarge")
imagen <- raster(rast(raster_filepath))
leaflet() |> 
  addTiles() |> 
  addRasterImage(imagen)
```

Como se inserta una imagen en el mapa, puede que el archivo html se haga muy grande y la carga sea muy lenta. Si la capa raster es muy grande, se puede usar `resample()` o `aggregate()` para reducir el número de celdas (y así el tamaño de archivo).

Para renderizar la `RasterLayer` como una imagen, cada valor de celda se convierte a un color RGB(A). Se puede especificar la escala de colores utilizando el argumento `colors`, que acepta una variedad de especificaciones de color:

* El nombre de una paleta de [Color Brewer 2](http://colorbrewer2.org/). Si no se proporciona ningún argumento de colores, el valor por defecto es "Espectral".
* Un vector que representa la lista ordenada de colores para asignar a los datos. Se puede utilizar cualquier especificación de color que sea aceptada por `grDevices::col2rgb()`, incluyendo las formas "#RRGGBB" y "#RRGGBBAA". Ejemplo: `colors = c("#E0F3DB", "#A8DDB5", "#43A2CA")`.
* Una función de escala de color, como las detalladas anteriormente. Por ejemplo: `colors = colorBin("Greens", domain = NULL, bins = 5, na.color = "transparent")`.

```{r}
pal <- colorNumeric(c("#0C2C84", "#41B6C4", "#FFFFCC"), values(imagen),
  na.color = "transparent")

leaflet() %>% addTiles() %>%
  addRasterImage(imagen, colors = pal, opacity = 0.8) %>%
  addLegend(pal = pal, values = values(imagen),
    title = "Elevation")
```


## Representación avanzada por capas con {mapview}

El [paquete {mapview}](https://r-spatial.github.io/mapview/index.html)  proporciona funciones para crear de forma muy rápida y cómoda visualizaciones interactivas de datos espaciales. Su objetivo principal es llenar el vacío de un trazado interactivo rápido para examinar e investigar visualmente ambos aspectos de los datos espaciales, las geometrías y sus atributos. También se puede considerar una API basada en datos para el paquete {leaflet}, ya que renderizará automáticamente los tipos de mapas correctos, dependiendo del tipo de datos (puntos, líneas, polígonos, raster). Además, hace uso de algunas funcionalidades avanzadas de renderizado que permitirán la visualización de datos mucho más grandes de lo que es posible con {leaflet}. 

La cantidad de opciones es inmensa, se recomienda consultar la documentación para conocer todas las posibilidades. Dos de las opciones más interesantes son:

* Automáticamente crea las capas de las distintas variables mapeadas, y la información adicional al hacer clic en el objeto espacial. Además, las capas se pueden mostrar y ocultar fácilmente, así como cambiar de fondo.

* Se pueden "mezclar" mapas sin más que "sumarlos". En el siguiente ejemplo se mezclan los datos de la renta con los de las estaciones de medición de contaminación.

```{r}
sfest <- st_as_sf(estaciones, coords = c("LONGITUD", "LATITUD"))
mapview(madrid, zcol = c("pob19", "propm", "Renta")) +
mapview(sfest)
```




